---
title: "Exploring risk for Dreissenid invasion"
author: "Todd Swannack, Iris Foxfoot, Kiara Cushway"
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
toc-title: "Table of contents"
sansfont: Calibri
---

# Purpose
This document summarizes the exploratory analysis we have conducted so far to assess and predict Dreissenid (*i.e.*, *Dreissena polymorpha* and *Dreissena rostriformis bugensis*) invasion in USACE reservoirs. 


# Data exploration

## Data description
A description of the datasets used can be found below:

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## Load necessary packages
library(tidyr)
library(randomForest) ## random forest algorithm
library(ROCR)
library(mlr)
library(dplyr)
library(FactoMineR)
library(factoextra)
library(knitr)
library(kableExtra)
library(ggplot2)
library(stringr)
library(caret)
library(sf) 
library(maps)

## Set seed to ensure consistent results
set.seed(123)
```


```{r attr.output='style="max-height: 500px;"',comment=''}
## Bring in metadata
cat(readLines("data/README_USACE_Reservoirs.txt"), sep = '\n')
```


## Infestation patterns in USACE reservoirs
Approximately 24% of the 352 reservoirs we examined have recorded Dreissenid presences according to USGS Non-indigenous Aquatic Species (NAS) data (Benson et al. 2024). The remaining 76% are currently considered un-infested (Table 1). Note that NAS data provides information on reports of Dreissenid presence only, and presence does not necessarily imply successful establishment. Absences are not reported.


```{r warning=FALSE, message=FALSE}


## Get state data
state_map = map_data("state")

## Load USACE reservoir data
res_raw = read_sf("USACE_Reservoirs/USACE_Reservoirs_Final.shp") %>% 
  janitor::clean_names() %>% 
  sf::st_make_valid() 

## Get centers of lakes
res_center = st_centroid(res_raw) %>% 
  select(infest_sta, name) %>% 
  mutate(infest_status = as.factor(infest_sta))

## Plot data
ggplot() +
  geom_polygon(data = state_map, aes(x = long,y = lat,group = group), inherit.aes = F, 
     colour = 'black', fill = NA) +
  geom_sf(data = res_center, aes(color = infest_status)) +
  scale_color_manual(values = c("0" = "blue", "1" = "red"), 
                     labels = c("0" = "absent", "1" = "present"),
                     name = "Dreissenid Presence") +
  labs(title = "Dreissenid presence in USACE reservoirs") +
  theme_void()
```

Figure 1. Location of Dreissenid infested and un-infested USACE reservoirs (n=352). Infestation status was determined using USGS Non-indigenous Aquatic Species data (Benson et al. 2024).

<br>
<br>

Table 1. Number of Dreissenid infested and un-infested USACE reservoirs (n=352). Infestation status was determined using USGS Non-indigenous Aquatic Species data (Benson et al. 2024).
```{r warning=FALSE, message=FALSE}

## Bring in data
ZQM_data= read.csv("data/USACE_Reservoirs_Final.csv")

## Subset data to include variables of interest only
ZQM = ZQM_data[,9:length(ZQM_data)]


## Count infested versus non-infested reservoirs
infest = summarise(group_by(ZQM,infest_status),count = n(),status = NA)
## 84 infested
## 268 not infested

## Set infestation status for table
for (i in 1:nrow(infest)) {
  if (infest$infest_status[i] == 0){
    infest$status[i] = "Un-infested"
  } else{
      infest$status[i] = "Infested"
    }
}

## Create table
kable(infest[,c(3,2)],col.names = c("Infestation status","Number of reservoirs"),align = "c") %>% kable_styling() %>% row_spec(2, extra_css = "border-bottom: 1px solid;") %>% row_spec(0, bold = T, font_size = 16, align = "c",extra_css = "border-bottom: 1px solid;")

```



## Environmental thresholds
We attempted to predict and assess Dreissenid infestation in USACE reservoirs using environmental data and assessed invasion risk based on discrete environmental thresholds that have been identified in the literature as facilitating or preventing Dreissenid invasion (Doll 1997; Sorba and Williamson 1997; Cohen and Weinstein 1998; Cohen 2005; Carrillo et al. 2023). We used these environmental thresholds to define reservoir characteristics that may lead to low, moderate, or high risk of Dreissenid infestation (Table 2). Since not all literature reported the same thresholds, we chose the most conservative values such that we were more likely to overestimate than underestimate risk of infestation. For example, if one study defined low risk habitat as areas with a hardness < 45 mg/L and another as < 55 mg/L, we selected 45 mg/L as the maximum hardness describing low risk habitat, resulting in a wider moderate risk category.


Table 2. Descriptions of environmental characteristics used in this analysis identified as contributing to low, moderate, or high risk of Dreissenid invasion. Note that in some cases, limited categorical data representing ranges was available for variables.
```{r warning=FALSE,message=FALSE,echo=FALSE}

## Bring in table of thresholds
threshold_defs = read.csv("data/env_thresholds.csv")

## Create formatted table to display thresholds
kable(threshold_defs,col.names = c("Metric", "Low risk", "Moderate risk", "High risk", "Reference"),align = c("l","c","c","c","l")) %>% kable_styling(full_width=T) %>% row_spec(0, bold = T, font_size = 16,extra_css = "border-bottom: 1px solid;") %>% row_spec(6, extra_css = "border-bottom: 1px solid;")

```


Using the data we compiled, we assigned each USACE reservoir as low, moderate, or high risk for each of the variables in Table 2 (Table 3). We then assessed how many reservoirs falling into each risk category were currently infested (Table 4, Figure 3) and assigned an overall risk for each reservoir by selecting the lowest risk category for any variable (Table 4, Table 5, Figure 3). Any reservoirs categorized as low risk for any of the variables were assigned a low overall risk, while reservoirs with no low risk variables and at least one moderate risk variable were assigned moderate risk. Reservoirs assigned high risk status for all variables were defined as having high overall risk. 


Table 3. Risk classifications for USACE reservoirs based on environmental thresholds known to influence Dreissenid survival. 
```{r}

## Bring in data
thresholds = read.csv("data/USACE_Reservoirs_Thresholds.csv")

## Assign risk categories based on environmental thresholds

## Loop through mean summer temperature to ID risk categories
for (i in 1:nrow(thresholds)) {
  if (thresholds$summer_mean_temp[i] < 15 | thresholds$summer_mean_temp[i] > 32) {
    thresholds$mean_sum_temp_threshold[i] = "Low"
  } else if ((thresholds$summer_mean_temp[i] >= 31 & thresholds$summer_mean_temp[i] <= 32)){
      thresholds$mean_sum_temp_threshold[i] = "Moderate"
    } else if (thresholds$summer_mean_temp[i] >= 15 | thresholds$summer_mean_temp[i] <= 31) {
      thresholds$mean_sum_temp_threshold[i] = "High"
    } else {
      thresholds$mean_sum_temp_threshold[i] = "Out of range"
  }
}


## Loop through max summer temperature to ID risk categories
for (i in 1:nrow(thresholds)) {
  if (thresholds$summer_max_temp[i] < 10 | thresholds$summer_max_temp[i] > 40) {
    thresholds$max_sum_temp_threshold[i] = "Low"
  } else if ((thresholds$summer_max_temp[i] >= 32 & thresholds$summer_max_temp[i] <= 40)){
      thresholds$max_sum_temp_threshold[i]="Moderate"
    } else if ((thresholds$summer_max_temp[i] >= 10 & thresholds$summer_max_temp[i] < 32)) {
    thresholds$max_sum_temp_threshold[i] = "High"
    } else {
      thresholds$max_sum_temp_threshold[i] = "Out of range"
  }
}


## Loop through pH to ID risk categories
for (i in 1:nrow(thresholds)) {
  if (thresholds$avg_pH[i] < 6.8 | thresholds$avg_pH[i] > 9.5) {
    thresholds$pH_threshold[i] = "Low"
  } else if ((thresholds$avg_pH[i] >= 6.8 & thresholds$avg_pH[i] < 7.4) | 
             (thresholds$avg_pH[i] > 8.7 & thresholds$avg_pH[i] <= 9.5)) {
      thresholds$pH_threshold[i] = "Moderate"
  } else if (thresholds$avg_pH[i] >= 7.4 & thresholds$avg_pH[i] <= 8.7) {
      thresholds$pH_threshold[i] = "High"
  } else {
      thresholds$pH_threshold[i] = "Out of range"
  }
}


## Loop through hardness to ID risk categories
for (i in 1:nrow(thresholds)) {
  if (thresholds$max_hardness[i] < 45) {
    thresholds$hardness_threshold[i] = "Low"
  } else if (thresholds$max_hardness[i] >= 45 & thresholds$max_hardness[i] <= 90) {
    thresholds$hardness_threshold[i] = "Moderate"
  } else if (thresholds$max_hardness[i] >= 90) {
    thresholds$hardness_threshold[i] = "High"
  } else {
      thresholds$hardness_threshold[i] = "Out of range"
  }
}

## Loop through calcium to ID risk categories
for (i in 1:nrow(thresholds)) {
  if (thresholds$avg_Ca[i] < 9) {
    thresholds$calcium_threshold[i] = "Low"
  } else if (thresholds$avg_Ca[i] >= 9 & thresholds$avg_Ca[i] <= 15) {
    thresholds$calcium_threshold[i] = "Moderate"
  } else if (thresholds$avg_Ca[i] > 15) {
    thresholds$calcium_threshold[i] = "High"
  } else {
      thresholds$calcium_threshold[i] = "Out of range"
  }
}

## Loop through distance to nearest infestation to ID risk categories
for (i in 1:nrow(thresholds)) {
  if(thresholds$dist_to_infest_km[i] > 160) {
    thresholds$dist_threshold_km[i] = "Low"
  } else if (thresholds$dist_to_infest_km[i] >= 80 & thresholds$dist_to_infest_km[i] <= 160) {
      thresholds$dist_threshold_km[i] = "Moderate"
  } else if (thresholds$dist_to_infest_km[i] < 80) {
      thresholds$dist_threshold_km[i] = "High"
  } else {
      thresholds$dist_threshold_km[i] = "Out of range"
  }
}


## Loop through risk categories to determine overall risk
for (i in 1:nrow(thresholds)) {
  if (sum(str_detect(thresholds[i,15:20], "Low")) > 0) {
    thresholds$overall_risk[i] = "Low"
  } else if ((sum(str_detect(thresholds[i,15:20], "Low")) == 0) & 
             (sum(str_detect(thresholds[i,15:20], "Moderate")) > 0)) {
      thresholds$overall_risk[i] = "Moderate"
  } else if (sum(str_detect(thresholds[i,15:20], "High")) == 6) {
     thresholds$overall_risk[i] = "High"
  } else {
    thresholds$overall_risk[i] = "ERROR"
  }
}

## Loop through risk categories to determine overall risk without considering distance to nearest infestation
for (i in 1:nrow(thresholds)) {
  if (sum(str_detect(thresholds[i,15:19], "Low")) > 0) {
    thresholds$overall_risk_nodist[i] = "Low"
  } else if ((sum(str_detect(thresholds[i,15:19], "Low")) == 0) & 
             (sum(str_detect(thresholds[i,15:19], "Moderate")) > 0)) {
      thresholds$overall_risk_nodist[i] = "Moderate"
  } else if (sum(str_detect(thresholds[i,15:19], "High")) == 5) {
     thresholds$overall_risk_nodist[i] = "High"
  } else {
    thresholds$overall_risk_nodist[i] = "ERROR"
  }
}


## Generate infestation status
for (i in 1:nrow(thresholds)) {
  if (thresholds$infest_status[i] == 1) {
    thresholds$infestation[i] = "Infested"
  } else {
    thresholds$infestation[i] = "Not infested"
  }
}

counts=thresholds %>% group_by(overall_risk,overall_risk_nodist) %>% summarise(count = n())

###Risk table
kable(thresholds[,c(1,15:23)],col.names=c("Reservoir","Mean summer temp risk threshold","Max summer temp risk threshold","pH risk threshold","Hardness risk threshold","Calcium risk threshold","Distance risk threshold","Overall risk", "Overall risk without distance","Infestation status"),align="c") %>% kable_styling()%>% 
 scroll_box(width = "1000px", height = "500px")%>% row_spec(0, bold = T, font_size = 16, align="c",extra_css = "border-bottom: 1px solid;")

```

<br>
<br>

Since distance to infestation is likely to change over time as Dreissenids become established in new locations, we also assessed whether risk status changed if distance was not considered as a risk factor. Not considering distance resulted in 11 reservoirs with a low overall risk being elevated to high risk, and an additional 26 being elevated to moderate risk. Additionally, nine reservoirs that were initially considered moderate risk based on distance to infestation were elevated to high risk. 

```{r}
## Bind threshold data to geo data
thresh_geo <- left_join(res_center, thresholds, join_by(name))

## Re-level factors
thresh_geo$overall_risk <- factor(thresh_geo$overall_risk, 
                                  levels = c("High", "Moderate", "Low"))

## plot data
ggplot() +
  geom_polygon(data = state_map, aes(x=long,y=lat,group=group), inherit.aes=F, 
     colour='black', fill=NA) +
  geom_sf(data = thresh_geo, aes(color = overall_risk)) +
  scale_color_manual(values = c("Low" = "#44AA99", "Moderate" = "#DDCC77", "High" = "#882255"),
                     name = "Risk of Dreissenid infestation") +
  labs(title = "Dreissenid invasion risk in USACE reservoirs") +
  theme_void()
```

Figure 2. Locations of low, moderate, and high risk reservoirs for dreissenid infestation. Risk was based on mean summer temperatures, maximum summer temperatures, total water hardness, water pH, and distance to the nearest infestation

```{r}
## Re-level variables
thresh_geo$overall_risk_dist <- factor(thresh_geo$overall_risk_nodist, 
                                  levels = c("High", "Moderate", "Low"))

## Plot graph
ggplot() +
  geom_polygon(data = state_map, aes(x=long,y=lat,group=group), inherit.aes=F, 
     colour='black', fill=NA) +
  geom_sf(data = thresh_geo, aes(color = overall_risk_nodist)) +
  scale_color_manual(values = c("Low" = "#44AA99", "Moderate" = "#DDCC77", "High" = "#882255"),
                     name = "Risk of Dreissenid infestation") +
  labs(title = "Dreissenid invasion risk in USACE reservoirs without\nconsidering distance to nearest invasion") +
  theme_void()

```

Figure 3. Location of low, moderate, and high risk reservoirs for Dreissenid infestation when not considering distance to nearest infestation as a risk factor. Risk was based on mean summer temperature, maximum summer temperature, total water hardness, calcium concentration, and pH. Low risk reservoirs in Arkansas and North Carolina/Georgia are caused by potentially unsuitable water chemistry. One reservoir in Arizona is considered unsuitable because of summer temperatures.

<br>
<br>

Table 4. Number of Dreissenid infested and un-infested reservoirs characterized as low, moderate, or high risk of invasion based on environmental characteristics.
```{r warning=FALSE,message=FALSE}

## Examine how risk category for each variable relates to infestation status

## Mean temperature
mean_temp = thresholds %>% group_by(mean_sum_temp_threshold,infestation) %>% summarise(count = n()) %>%
  pivot_wider(names_from = mean_sum_temp_threshold, values_from = count) %>% mutate(var = "Mean temperature") %>% mutate(Moderate = NA)

## Max temperature
max_temp = thresholds %>% group_by(max_sum_temp_threshold,infestation) %>% summarise(count=n()) %>%
  pivot_wider(names_from = max_sum_temp_threshold, values_from = count) %>% mutate(var = "Max temperature")

## pH
pH = thresholds %>% group_by(pH_threshold,infestation) %>% summarise(count=n()) %>%
  pivot_wider(names_from = pH_threshold, values_from = count) %>% mutate(var = "pH")

## Hardness
hardness = thresholds %>% group_by(hardness_threshold,infestation) %>% summarise(count = n()) %>%
  pivot_wider(names_from = hardness_threshold, values_from = count) %>% mutate(var = "Hardness")

## Calcium
calcium = thresholds %>% group_by(calcium_threshold,infestation) %>% summarise(count = n()) %>%
  pivot_wider(names_from = calcium_threshold, values_from = count) %>% mutate(var = "Calcium")

## Distance
distance = thresholds %>% group_by(dist_threshold_km,infestation) %>% summarise(count=n()) %>%
  pivot_wider(names_from = dist_threshold_km, values_from = count) %>% mutate(var = "Distance to nearest infestation")

## Combine into a single table
risk=rbind(mean_temp,max_temp,pH,hardness,calcium,distance)

## Replace NAs with zeroes
risk$Moderate=risk$Moderate %>% replace_na(0)
risk$Low=risk$Low %>% replace_na(0)
risk$High=risk$High %>% replace_na(0)

## Re-arrange order of columns
risk=risk[,c(4,1,3,5,2)]

## Display results in table format
kable(risk,col.names = c("Environmental variable","Infestation status","Low risk of invasion","Moderate risk of invasion", "High risk of invasion"),align = "c") %>% kable_styling() %>% collapse_rows(columns = 1,valign="top") %>% row_spec(0, bold = T, font_size = 16, align = "c",extra_css = "border-bottom: 1px solid;") %>% row_spec(10, extra_css = "border-bottom: 1px solid;") %>% column_spec(1,extra_css = "border-bottom: 1px solid;") %>% row_spec(c(2,4,6,8,10,12),extra_css = "border-bottom: 1px solid") %>% scroll_box(width = "1000px", height = "500px")
```
<br>
<br>
<br>


```{r warning=FALSE, message=FALSE,fig.height=30,fig.width=45}

## Graph low, moderate, and high risk according to infested and uninfested

## Change data format to longer
risk_long=risk %>% pivot_longer(cols=c("Low","Moderate","High"),names_to = "Risk_level")

risk_long$order=c(1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3)

risk_long %>% ggplot(aes(fill=infestation,y=value,x=reorder(Risk_level,order)))+ geom_bar(position="dodge",stat="identity")+facet_wrap(~var,ncol=3,nrow=2)+labs(x="Risk level",y="Number of reservoirs")+ theme(text=element_text(size=50))+scale_fill_manual(values=c("navyblue","orchid"),name="Infestation status")

```
Figure 4. Number of Dreissenid infested and un-infested USACE reservoirs falling into each risk category (low, moderate, or high) for specified variables.

<br>
<br>

Table 5. Percent of USACE reservoirs falling into each risk category for Dreissenid infestation.
```{r warning=FALSE, message=FALSE}

## Summarise percent of reservoirs in each risk category
overall_risk_pct=thresholds %>% group_by(overall_risk) %>% summarise(pct = round(n()/352*100,2)) %>% pivot_wider(names_from = overall_risk, values_from = pct)

overall_risk_pct = overall_risk_pct[,c(2,3,1)]

kable(overall_risk_pct,align = "c",col.names = c("Low risk (%)","Moderate risk (%)", "High risk (%)")) %>% kable_styling() %>% row_spec(0, bold = T, font_size = 16, align = "c",extra_css = "border-bottom: 1px solid;") %>% row_spec(1, extra_css = "border-bottom: 1px solid;")

```

<br>
<br>

Table 6. Number of Dreissenid infested or un-infested reservoirs categorized as low, moderate, or high risk for Dreissenid invasion based on factors like mean and max summer temperature, pH, hardness, and distance to other infested water bodies.

```{r warning=FALSE, message=FALSE}

## Summarise number of infested and uninfested lakes in each risk category
overall_risk = thresholds %>% group_by(overall_risk,infestation) %>% summarise(count = n()) %>% pivot_wider(names_from = overall_risk, values_from = count)

overall_risk = overall_risk[,c(1,3,4,2)]

kable(overall_risk,align = "c",col.names = c("Infestation status","Low risk","Moderate risk", "High risk")) %>% kable_styling() %>% row_spec(0, bold = T, font_size = 16, align = "c",extra_css = "border-bottom: 1px solid;") %>% row_spec(2, extra_css = "border-bottom: 1px solid;")

```




```{r warning=FALSE, message=FALSE,fig.height=15,fig.width=45}

## Graph low, moderate, and high risk according to infested and uninfested

## Change data format to longer
overall_risk_long = overall_risk %>% pivot_longer(cols = c("Low","Moderate","High"),names_to = "Risk_level")

overall_risk_long$order = c(1,2,3,1,2,3)

overall_risk_long %>% ggplot(aes(fill = infestation,y = value,x = reorder(Risk_level,order))) + geom_bar(position = "dodge",stat = "identity") + labs(x = "Risk level", y = "Number of reservoirs") + theme(text = element_text(size = 80)) + scale_fill_manual(values = c("navyblue","orchid"),name = "Infestation status")

```
Figure 5. Number of USACE reservoirs falling into each overall risk category that are infested or un-infested with Dreissenids.

<br>
<br>

Of the reservoirs considered to be at low risk of Dreissenid invasion, six reservoirs actually have Dreissenid infestations already (Table 7). These reservoirs fell into the low risk categories based on calcium, hardness, or pH levels considered lower than acceptable. However, it is important to remember that these estimates are based on interpolated data, and that water quality can vary within water bodies.

<br>
<br>

Table 7. Reservoirs characterized as having an overall low risk of Dreissenid invasion despite being infested with Dreissenids.

```{r}
## Check out low risk lakes that are infested
low_risk_infested = c(NA,NA)

for (i in 1:nrow(thresholds)) {
  if (sum(str_detect(thresholds[i,21], "Low")) > 0 & thresholds$infest_status[i] == 1){
    low_risk_infested[i] = thresholds$name[i]
  } else {
  }
}



low_risk_infested_info = thresholds %>% filter(name %in% low_risk_infested[which(!is.na(low_risk_infested))])

kable(low_risk_infested_info[,c(1,15:22)],col.names = c("Reservoir","Mean summer temp risk threshold","Max summer temp risk threshold","pH risk threshold","Hardness risk threshold","Calcium risk threshold","Distance risk threshold","Overall risk","Overall risk without distance"),align = "c") %>% kable_styling() %>% row_spec(0, bold = T, font_size = 16, align = "c",extra_css = "border-bottom: 1px solid;") %>% row_spec(6, extra_css = "border-bottom: 1px solid;")

```
<br>
<br>


# Data analysis

Next, we used the data available on a national scale to try to better understand how different environmental and social factors may be related to Dreissenid presence in USACE reservoirs. We explored several analysis methods to investigate our questions, which are outlined below:

<br>
<br>

## Logistic regressions

We ran several exploratory logistic regression models using binary infested (1) versus not infested (0) as the response variable. We used different predictor variables in each logistic regression. Our goal was not to predict Dreissenid infestation, but rather to identify significant environmental predictors and the directionality of their influence.

<br>
<br>

### Landcover logistic regression

We ran a logistic regression with the proportion of land use categories within a 25 and 50 mile buffer of each reservoir as predictor variables. Data was from the NLCD.

First we ran the model with a 50 mile buffer for each land cover category.

Note that the model did not converge with percent perennial snow and ice included in the logistic regression.

Below is the model summary:

```{r}
#some data cleaning
landcover_50  <- ZQM_data %>%
  select(infest_status, c(perc_open_water_50mi, perc_dev_openspace_50mi: perc_wetland_50mi)) %>% 
  mutate(infest_status = as.factor(infest_status))

#run the model
landcover_50_logit <- glm(infest_status ~ ., data = landcover_50, family = "binomial")

#print model summary
summary(landcover_50_logit)
```

Notes: In this model, there are no significant predictors of infestation.

We then ran the model with a 25 mile buffer. Note that the model did not converge with percent open water or percent snow and ice variables included.

```{r}
#some data cleaning
landcover_25  <- ZQM_data %>%
  select(infest_status, c(perc_dev_openspace_25mi: perc_wetland_25mi)) %>% 
  mutate(infest_status = as.factor(infest_status))

#run the model
landcover_25_logit <- glm(infest_status ~ ., data = landcover_25, family = "binomial")

#print model summary
summary(landcover_25_logit)
```

Notes: When we ran the model with a 25 mile buffer, it showed forest cover, shrub cover, herbaceous cover, percent crop cover, and percent wetland cover to be significant predictors of infestation. It did not show any development categories to be significant. Both models had weak predictive power, indicating they were not very accurate.

In the next model, we aggregate all development classifications into a single category, again using the 25 mile buffer.

```{r}
#looking at what happens when development landcovers are summed
dev_sum <- ZQM_data %>% 
  mutate(dev_sum_25mi = perc_dev_openspace_25mi + perc_dev_lowintensity_25mi + perc_dev_medintensity_25mi + perc_dev_highintensity_25mi) %>% 
  select(dev_sum_25mi, infest_status, c(perc_barren_25mi:perc_wetland_25mi)) %>% 
  mutate(infest_status = as.factor(infest_status))

#run new model
dev_sum_25_logit <- glm(infest_status ~ ., data = dev_sum, family = "binomial")

#summarise new model
summary(dev_sum_25_logit)
```

Notes: The model showed all variables except percent barren land to be significant. Development is weakly significant. Overall the model has poor predictive power.
<br>
<br>

### Water chemistry and geology

Next we ran a logistic regression with various water chemistry and geology characteristics as predictors. For hardness, we used the midpoint of the given range of values. Below is the model summary.

```{r}
#looking at geology and water chemistry
water_chem <- ZQM_data %>% 
  mutate(mean_hardness = (min_hardness + max_hardness)/2) %>% 
  select(infest_status, avg_Ca,avg_pH, mean_hardness, c(perc_alluvial_25mi:perc_resid_volcanic_art_wat_25mi)) %>% 
  mutate(infest_status = as.factor(infest_status))

#run the model
water_chem_logit <- glm(infest_status ~ ., data = water_chem, family = "binomial")

#print summary
summary(water_chem_logit)
```

Notes: This model seems to indicate that pH is a statistically significant predictors of infestation. This model has a comparatively higher AIC score, indicating poor model performance.
<br>
<br>

### Climate

We also ran a logistic regression with various climate variables as predictors. Note that climate variables are likely all correlated, which is not ideal for logistic regression. This model is for exploratory purposes only.

```{r}
#looking at climate
climate <- ZQM_data %>% 
  select(infest_status, c(winter_total_precip:fall_max_temp)) %>% 
  mutate(infest_status = as.factor(infest_status))

#run the model
climate_logit <- glm(infest_status ~., data = climate, family = "binomial")

#print model summary
summary(climate_logit)
```
Note: This model shows spring temperature as being potentially important.

We also ran a logistic regression with just seasonal mean temperatures as predictor variables.

```{r}
#looking at just mean temps
mean_temp <- climate %>% 
  select(infest_status, spring_mean_temp, summer_mean_temp, fall_mean_temp, winter_mean_temp) %>% 
  mutate(infest_status = as.factor(infest_status))

#run model with mean temps
mean_temp_logit <- glm(infest_status ~., data = mean_temp, family = "binomial")

#print model summary
summary(mean_temp_logit)
```

Note: When looking at just mean temps, spring temps are no longer most significant and they do not have particularly strong influence on infestation. In this model, winter temps have a significant negative relationship with infestation.
<br>
<br>

### Size, recreation, and connectivity

```{r, warning=FALSE}
## Looking at proximity to water bodies, connection status, etc
connectivity <- ZQM_data %>% 
  select(infest_status, dist_to_infest_km, surface_area_km, connectivity, mean_total_visits) %>% 
  mutate(infest_status = as.factor(infest_status))

#set factor levels for connectivity
connectivity$connectivity <- factor(connectivity$connectivity, levels = c("None", "Dam", "Lock and Dam"))

#run model
connect_logit <- glm(infest_status ~., data = connectivity, family = "binomial")

#print model summary
summary(connect_logit)
```

Notes: distance to infestation is the most significant predictor, and surface area is also significant. Increasing distance has a negative relationship with infestation while increasing surface area has a slight positive relationship with infestation. This model has lowest AIC so far, indicating better predictive power when compared with the previous logistic regression models.

## Gradient boosted model

A gradient boosted model is a flexible machine learning algorithm that is immune to issues caused by multicollinearity. It works by combining multiple weak models (think small decision trees) into one strong model.

In this instance, we split the data into training data to train the model and testing data to test the model. Since there is so little data, taking even a few observations away to later test the model on may impact the model training.

Below is a summary of the model, trained using the training data.

```{r warning=FALSE,message=FALSE,fig.height=20,fig.width=20,attr.output='style="max-height: 500px;"'}
library(gbm) #for gradient boosting models
library(Metrics) #for RMSE calculation
library(rsample) #for splitting data into test and training

#prepare data for gradient boosted tree
boosted_data <- ZQM_data %>% 
  select(dist_to_infest_km:infest_status) %>% 
  select(-hardness_range) %>% 
  mutate(connectivity = as.factor(connectivity)) %>% 
  mutate(infest_status = as.numeric(infest_status))

#set factor levels for connectivity
boosted_data$connectivity <- factor(boosted_data$connectivity, levels = c("None", "Dam", "Lock and Dam"))

#define split parameters
boosted_data_split <- boosted_data %>% 
  initial_split(prop = 0.8, strata = infest_status)

#write split data to data frames
train_split <- training(boosted_data_split)
test_split <- testing(boosted_data_split)

#run model
infest_gbm = gbm(infest_status ~ ., 
                 distribution = "bernoulli",
                 data = train_split,
                 n.trees = 1000,
                 shrinkage = 0.01,
                 interaction.depth = 4)
#print model
infest_gbm
```

Below is a list of the most influential variables, according to the gradient boosted model.

```{r warning=FALSE,message=FALSE,fig.height=20,fig.width=20,attr.output='style="max-height: 500px;"'}
#the model summary
summary(infest_gbm, plotit = F)
```

Note: Distance to infestation is vastly more important than other predictors. 

It is also possible to see the general relationship between the predictor variables and the outcome variable. Below are two figures showing the relationship between infestation on the Y axis and the predictor variable on the X axis.

```{r}
#plot some rough graphs showing relationship between infestation and key vars
plot(infest_gbm,i="dist_to_infest_km")
```

Figure 7. There is a negative relationship between infestation and the distance to the nearest infected body of water. Infestation is much more likely when other infestations are close.

```{r}
plot(infest_gbm,i="surface_area_km") 
```

Figure 8. There is a positive relationship between infestation and the size of the reservoir. Larger reservoirs are more likely to be infested.

```{r}
plot(infest_gbm,i="mean_total_visits") 
```
Figure 9. There is a positive relationship between average number of recreational visitors and infestation status.

```{r}
plot(infest_gbm,i="max_Ca") 
```
Figure 10: There is a positive relationship between maximum observed median calcium levels and infestation status.
<br>
<br>

Next we use the model to generate predictions. We will then create a confusion matrix and calculate RMSE. Below is a confusion matrix for the training data.

```{r, message=FALSE}
confusionMatrix(table(predict(infest_gbm, newdata = train_split,
                              type="response") >= 0.5,
                      train_split$infest_status == 1))
```

Below is the RMSE for the training data
```{r, message=FALSE}
#create predictions
predictions_training <- predict(infest_gbm, newdata = train_split, type = "response")

#calculate RMSE for training data
Metrics::rmse(predictions_training, train_split$infest_status)
```

Below is a confusion matrix for the test data.

```{r, message=FALSE}
#testing model

confusionMatrix(table(predict(infest_gbm, newdata = test_split,
                              type="response") >= 0.5,
                      test_split$infest_status == 1))
```

Below is RMSE for the test data.

```{r, message=FALSE}
#create predictions
predictions_test <- predict.gbm(infest_gbm, newdata = test_split, type = "response")

#calculate RMSE for training data
Metrics::rmse(predictions_test, test_split$infest_status)
```

The shows some signs of overfitting. It "predicts" infestation with perfect accuracy when given the training data, but it is less accurate when predicting infestation with new data. Still, the model is reasonably effective and may be further improved with model tuning.

<br>
<br>


## Random forest analysis 

Random forest classification is a type of machine learning that functions similarly to classification and regression tree analysis (CART). Random forest analysis does not assume linearity, normality, or homoscedasticity and is less sensitive to spatial autocorrelation and multicollinearity. 

Random forest classification works by generating a series of bootstrapped trees that have low correlation with one another and averaging the results of these individual trees across a "forest" of many trees to prevent overfitting. Individual trees are created by randomly selecting a subset of all possible variables and using them to build and test a classification scheme using randomly selected training (64%) and test data (36%). Since each tree uses a random subset of variables and different training and test data, they should be relatively different from one another.

We can evaluate the performance of the random forest classification by obtaining an estimate of out-of-bag (OOB) error, which describes the overall percentage of incorrectly categorized data (in this case presence versus absence), averaged across trees.

We used the 'randomForest' package in R to run this analysis (Liaw and Wiener, 2002).

We obtained several outputs from the random forest classification, including:

1) Out-of-bag error (OOB): overall error of classification (average % of time random forest incorrectly classifies records)
2) False positive rate: Average percent of records categorized as having a Dreissenid infestation where Dreissenids are actually absent
3) False negative rate: Average percent of records categorized as having no Dreissenid infestation where Dreissenids are actually present
4) Importance: The average decrease in model accuracy if a given variable were dropped from the analysis

To run our random forest classification, we created 10000 trees using the default settings, including:

mtry: number of variables randomly sampled as candidates at each split (sqrt(p) by default, where p is the number of variables). Should we pursue RF further, we may want to experiment with different mtrys.

nodesize: minimum size of terminal nodes (1 by default)

### Random forest with test and training datasets

Below is a random forest model trained with the same training data given to the gradient boosted model. First the variable importance is displayed:

```{r}
## Random forest with training and test datasets

## Train the model

infest_rf = randomForest(as.factor(infest_status) ~ ., #writing the formula
                          data = train_split, #specifying training data to be used
                          mtry = 9, #setting number of variables to randomly sample per each split
                          ntree= 500, #setting number of trees
                          na.action = na.omit, #specifying what to do with NAs
                          importance = TRUE #specifying importance of variables should be assessed
                          )

## Check variable importance
variable_importance = importance(infest_rf)
sorted_importance = data.frame(variable_importance[order(-variable_importance[, 1]), ])
par(mar = c(10, 2, 2, 2)) # Set the margin on all sides 
barplot(sorted_importance[, 1], names.arg = rownames(sorted_importance), las = 2, col = "blue", main = "Variable Importance",cex.names = 1)

```

Then we will create a confusion matrix for the training data.

```{r attr.output='style="max-height: 500px;"'}
#training confusion matrix
p_train <- predict(infest_rf, newdata = train_split)
confusionMatrix(p_train, as.factor(train_split$infest_status))
```

Followed by a confusion matrix for the test data.

```{r attr.output='style="max-height: 500px;"'}
#test confusion matrix
p_test <- predict(infest_rf, newdata = test_split)
confusionMatrix(p_test, as.factor(test_split$infest_status))

#No RMSE for categorical outcomes in RF

```
<br>
<br>
<br>

## Random forest with reduced variables

Here we will try the random forest using only the variables identified for risk thresholds.

```{r}
## Random forest with training and test datasets

train_split_red = train_split %>% select(c(dist_to_infest_km,avg_Ca,avg_pH,max_hardness,summer_mean_temp,summer_max_temp,infest_status))

test_split_red = test_split %>% select(c(dist_to_infest_km,avg_Ca,avg_pH,max_hardness,summer_mean_temp,summer_max_temp,infest_status))

## Train the model
rf_risk_vars = randomForest(as.factor(infest_status) ~ ., #writing the formula
                          data = train_split_red, #specifying training data to be used
                          mtry = 2.44949, #setting number of variables to randomly sample per each split
                          ntree= 500, #setting number of trees
                          na.action = na.omit, #specifying what to do with NAs
                          importance = TRUE #specifying importance of variables should be assessed
                          )

## Check variable importance
variable_importance = importance(rf_risk_vars)
sorted_importance = data.frame(variable_importance[order(-variable_importance[, 1]), ])
par(mar = c(10, 2, 2, 2)) # Set the margin on all sides 
barplot(sorted_importance[, 1], names.arg = rownames(sorted_importance), las = 2, col = "blue", main = "Variable Importance",cex.names = 1)
```
<br>
<br>
Then we will create a confusion matrix for the training data.

```{r attr.output='style="max-height: 500px;"'}
#training confusion matrix
p_train <- predict(rf_risk_vars, newdata = train_split_red)
confusionMatrix(p_train, as.factor(train_split_red$infest_status))
```

```{r attr.output='style="max-height: 500px;"'}
#test confusion matrix
p_test <- predict(rf_risk_vars, newdata = test_split_red)
confusionMatrix(p_test, as.factor(test_split_red$infest_status))

#No RMSE for categorical outcomes in RF

```
## Random forest with reduced variables no temperature

Here we will try the random forest using only the variables identified for risk thresholds, but excluding temperature risk thresholds.

```{r}
## Random forest with training and test datasets

train_split_red_temp = train_split %>% select(c(dist_to_infest_km,avg_Ca,avg_pH,max_hardness,infest_status))

test_split_red_temp = test_split %>% select(c(dist_to_infest_km,avg_Ca,avg_pH,max_hardness,infest_status))

## Train the model
rf_risk_vars_temp = randomForest(as.factor(infest_status) ~ ., #writing the formula
                          data = train_split_red_temp, #specifying training data to be used
                          mtry = 2, #setting number of variables to randomly sample per each split
                          ntree= 500, #setting number of trees
                          na.action = na.omit, #specifying what to do with NAs
                          importance = TRUE #specifying importance of variables should be assessed
                          )

## Check variable importance
variable_importance = importance(rf_risk_vars_temp)
sorted_importance = data.frame(variable_importance[order(-variable_importance[, 1]), ])
par(mar = c(10, 2, 2, 2)) # Set the margin on all sides 
barplot(sorted_importance[, 1], names.arg = rownames(sorted_importance), las = 2, col = "blue", main = "Variable Importance",cex.names = 1)
```

<br>
<br>
Then we will create a confusion matrix for the training data.

```{r attr.output='style="max-height: 500px;"'}
#training confusion matrix
p_train <- predict(rf_risk_vars_temp, newdata = train_split_red_temp)
confusionMatrix(p_train, as.factor(train_split_red_temp$infest_status))
```

```{r attr.output='style="max-height: 500px;"'}
#test confusion matrix
p_test <- predict(rf_risk_vars_temp, newdata = test_split_red_temp)
confusionMatrix(p_test, as.factor(test_split_red_temp$infest_status))

#No RMSE for categorical outcomes in RF

```

<br>
<br>
<br>

# References

Benson, A. J., Raikow, D., Larson, J., Fusaro, A., Bogdanoff, A. K., and A. Elgin. (2024). *Dreissena polymorpha* (Pallas, 1771): U.S. Geological Survey, Nonindigenous Aquatic Species Database, Gainesville, Florida. https://nas.er.usgs.gov/queries/FactSheet.aspx?speciesID=5, Revision Date: 12/21/2023, Access Date: 7/29/2024

Carrillo, C. C., Charbonneau, B. R., Altman, S., Keele, J. A., Pucherelli, S. F., Passamaneck, Y. J., Murphy, A. C., and T. M. Swannack. (2023). Patterns of dreissenid mussel invasions in western US lakes within an integrated gravity model framework.

Kislik, C., Dronova, I., Grantham, T. E., Kelly, M. (2022) Mapping algal bloom dynamics in small reservoirs using Sentinel-2 imagery in Google Earth Engine. Ecological Indicators, Volume 140. https://doi.org/10.1016/j.ecolind.2022.109041.

Cohen, A. N. (2005). A review of Zebra Mussels' environmental requirements: a report for the California Department of Water Resources. San Francisco Estuary Institute, Oakland, California. 33 pp.

Cohen, A. N., and A. Weinstein. (1998). The potential distribution and abundance of Zebra Mussels in California. San Francisco Estuary Institute, Richmond, California. 

Doll, B. (1997). Zebra Mussel colonization: North Carolina's risks. Sea Grant North Carolina, Raleigh, North Carolina (UNC SG-97-01).

Liaw A, and M. Wiener. (2002). Classification and regression by Random Forest. R News. 2(3):18–22. Available
from: https://CRAN.R-project.org/doc/Rnews/.

Mishra, Sachidananda & Mishra, Deepak. (2012). Normalized difference chlorophyll index: A novel model for remote estimation of chlorophyll-a concentration in turbid productive waters. Remote Sensing of Environment. 117. 394-406. 10.1016/j.rse.2011.10.016. 

Sorba, E. A., and D. A. Williamson. (1997). Zebra Mussel colonization potential in Manitoba, Canada. Water Quality Management Section, Manitoba Environment, Report No. 97-07.








