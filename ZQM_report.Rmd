---
title: "Exploring risk for Dreissenid invasion"
author: "Todd Swannack, Iris Foxfoot, Kiara Cushway"
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
toc-title: "Table of contents"
sansfont: Calibri
---

# Purpose
This document summarizes the exploratory analysis we have conducted so far to assess and predict Dreissenid (*i.e.*, *Dreissena polymorpha* and *Dreissena rostriformis bugensis*) invasion in USACE reservoirs.

# Data exploration

## Data description
A description of the datasets used can be found below:

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## Load necessary packages
library(tidyr)
library(randomForest) ## random forest algorithm
library(ROCR)
library(mlr)
library(dplyr)
library(FactoMineR)
library(factoextra)
library(knitr)
library(kableExtra)
library(ggplot2)
library(stringr)
library(caret)
library(sf) 
library(maps)
library(corrplot)

## Set seed to ensure consistent results
set.seed(123)
```

```{r attr.output='style="max-height: 500px;"',comment=''}
## Bring in metadata
cat(readLines("data/README_USACE_Reservoirs.txt"), sep = '\n')
```

## Infestation patterns in USACE reservoirs

Approximately 24% of the 352 reservoirs we examined have recorded Dreissenid presences according to USGS Non-indigenous Aquatic Species (NAS) data (Benson et al. 2024). The remaining 76% are currently considered un-infested (Table 1). Note that NAS data provides information on reports of Dreissenid presence only, and presence does not necessarily imply successful establishment. Absences are not reported. Note also that the absence of positive records in a state (e.g., Michigan) does not imply that Dreissenids are not present there, just that no Dreissenids have been recorded in USACE reservoirs within the state.

```{r warning=FALSE, message=FALSE}


## Get state data
state_map = map_data("state")

## Load USACE reservoir data
res_raw = read_sf("USACE_Reservoirs/USACE_Reservoirs_Final.shp") %>% 
  janitor::clean_names() %>% 
  sf::st_make_valid() 

## Get centers of lakes
res_center = st_centroid(res_raw) %>% 
  select(infest_sta, name) %>% 
  mutate(infest_status = as.factor(infest_sta))

## Plot data
ggplot() +
  geom_polygon(data = state_map, aes(x = long,y = lat,group = group), inherit.aes = F, 
     colour = 'black', fill = NA) +
  geom_sf(data = res_center, aes(color = infest_status)) +
  scale_color_manual(values = c("0" = "blue", "1" = "red"), 
                     labels = c("0" = "absent", "1" = "present"),
                     name = "Dreissenid Presence") +
  labs(title = "Dreissenid presence in USACE reservoirs") +
  theme_void()
```

Figure 1. Location of Dreissenid infested and un-infested USACE reservoirs (n=352). Infestation status was determined using USGS Non-indigenous Aquatic Species data (Benson et al. 2024).

<br> <br>

Table 1. Number of Dreissenid infested and un-infested USACE reservoirs (n=352). Infestation status was determined using USGS Non-indigenous Aquatic Species data (Benson et al. 2024).

```{r warning=FALSE, message=FALSE}

## Bring in data
ZQM_data= read.csv("data/USACE_Reservoirs_Final.csv")

## Subset data to include variables of interest only
ZQM = ZQM_data[,9:length(ZQM_data)]


## Count infested versus non-infested reservoirs
infest = summarise(group_by(ZQM,infest_status),count = n(),status = NA)
## 84 infested
## 268 not infested

## Set infestation status for table
for (i in 1:nrow(infest)) {
  if (infest$infest_status[i] == 0){
    infest$status[i] = "Un-infested"
  } else{
      infest$status[i] = "Infested"
    }
}

## Create table
kable(infest[,c(3,2)],col.names = c("Infestation status","Number of reservoirs"),align = "c") %>% kable_styling() %>% row_spec(2, extra_css = "border-bottom: 1px solid;") %>% row_spec(0, bold = T, font_size = 16, align = "c",extra_css = "border-bottom: 1px solid;")

```

## Environmental thresholds

We attempted to predict and assess Dreissenid infestation in USACE reservoirs using environmental data and assessed invasion risk based on discrete environmental thresholds that have been identified in the literature as facilitating or preventing Dreissenid invasion (Doll 1997; Sorba and Williamson 1997; Cohen and Weinstein 1998; Cohen 2005; Carrillo et al. 2023). We used these environmental thresholds to define reservoir characteristics that may lead to low, moderate, or high risk of Dreissenid infestation (Table 2). Since not all literature reported the same thresholds, we chose the most conservative values such that we were more likely to overestimate than underestimate risk of infestation. For example, if one study defined low risk habitat as areas with a hardness < 45 mg/L and another as < 55 mg/L, we selected 45 mg/L as the maximum hardness describing low risk habitat, resulting in a wider moderate risk category.

Initially, we included maximum summer temperature in our risk assessment, but we found that the risk categories identified were not necessarily a good representation of invasion risk, as a higher proportion of moderate-risk reservoirs were already invaded by Dreissenids compared to high risk reservoirs. While maximum temperature is likely a factor that does limit Dreissenid range, the duration of high temperature events may be an important factor that was missing from our assessment. Since we have no information about how long maximum summer temperatures occurred, it is difficult to assess their affect on mussels, as Dreissenids may be able to survive short-term exposure to high temperatures but could have higher mortality during longer high temperature events (White et al., 2015). Hence, we removed maximum temperature from our risk assessment but included it in our statistical analyses investigating the relationship between environmental parameters and Dreissenid presence.

Table 2. Descriptions of environmental characteristics used in this analysis identified as contributing to low, moderate, or high risk of Dreissenid invasion. Note that in some cases, limited categorical data representing ranges was available for variables.

```{r warning=FALSE,message=FALSE,echo=FALSE}

## Bring in table of thresholds
threshold_defs = read.csv("data/env_thresholds.csv")

## Create formatted table to display thresholds
kable(threshold_defs,col.names = c("Metric", "Low risk", "Moderate risk", "High risk", "Reference"),align = c("l","c","c","c","l")) %>% kable_styling(full_width=T) %>% row_spec(0, bold = T, font_size = 16,extra_css = "border-bottom: 1px solid;") %>% row_spec(5, extra_css = "border-bottom: 1px solid;")

```

Using the data we compiled, we assigned each USACE reservoir as low, moderate, or high risk for each of the variables in Table 2 (Table 3). We then assessed how many reservoirs falling into each risk category were currently infested (Table 4, Figure 3) and assigned an overall risk for each reservoir by selecting the lowest risk category for any variable (Table 4, Table 5, Figure 3). Any reservoirs categorized as low risk for any of the variables were assigned a low overall risk, while reservoirs with no low risk variables and at least one moderate risk variable were assigned moderate risk. Reservoirs assigned high risk status for all variables were defined as having high overall risk.

Table 3. Risk classifications for USACE reservoirs based on environmental thresholds known to influence Dreissenid survival.

```{r, message=FALSE, warning=FALSE}

## Bring in data
thresholds = read.csv("data/USACE_Reservoirs_Thresholds.csv")

## Assign risk categories based on environmental thresholds

## Loop through mean summer temperature to ID risk categories
for (i in 1:nrow(thresholds)) {
  if (thresholds$summer_mean_temp[i] < 15 | thresholds$summer_mean_temp[i] > 32) {
    thresholds$mean_sum_temp_threshold[i] = "Low"
  } else if ((thresholds$summer_mean_temp[i] >= 31 & thresholds$summer_mean_temp[i] <= 32)){
      thresholds$mean_sum_temp_threshold[i] = "Moderate"
    } else if (thresholds$summer_mean_temp[i] >= 15 | thresholds$summer_mean_temp[i] <= 31) {
      thresholds$mean_sum_temp_threshold[i] = "High"
    } else {
      thresholds$mean_sum_temp_threshold[i] = "Out of range"
  }
}


## Loop through pH to ID risk categories
for (i in 1:nrow(thresholds)) {
  if (thresholds$max_pH[i] < 6.8 | thresholds$max_pH[i] > 9.5) {
    thresholds$pH_threshold[i] = "Low"
  } else if ((thresholds$max_pH[i] >= 6.8 & thresholds$max_pH[i] < 7.4) | 
             (thresholds$max_pH[i] > 8.7 & thresholds$max_pH[i] <= 9.5)) {
      thresholds$pH_threshold[i] = "Moderate"
  } else if (thresholds$max_pH[i] >= 7.4 & thresholds$max_pH[i] <= 8.7) {
      thresholds$pH_threshold[i] = "High"
  } else {
      thresholds$pH_threshold[i] = "Out of range"
  }
}


## Loop through hardness to ID risk categories
for (i in 1:nrow(thresholds)) {
  if (thresholds$max_hardness[i] < 45) {
    thresholds$hardness_threshold[i] = "Low"
  } else if (thresholds$max_hardness[i] >= 45 & thresholds$max_hardness[i] <= 90) {
    thresholds$hardness_threshold[i] = "Moderate"
  } else if (thresholds$max_hardness[i] >= 90) {
    thresholds$hardness_threshold[i] = "High"
  } else {
      thresholds$hardness_threshold[i] = "Out of range"
  }
}

## Loop through calcium to ID risk categories
for (i in 1:nrow(thresholds)) {
  if (thresholds$max_Ca[i] < 9) {
    thresholds$calcium_threshold[i] = "Low"
  } else if (thresholds$max_Ca[i] >= 9 & thresholds$max_Ca[i] <= 15) {
    thresholds$calcium_threshold[i] = "Moderate"
  } else if (thresholds$max_Ca[i] > 15) {
    thresholds$calcium_threshold[i] = "High"
  } else {
      thresholds$calcium_threshold[i] = "Out of range"
  }
}

## Loop through distance to nearest infestation to ID risk categories
for (i in 1:nrow(thresholds)) {
  if(thresholds$dist_to_infest_km[i] > 160) {
    thresholds$dist_threshold_km[i] = "Low"
  } else if (thresholds$dist_to_infest_km[i] >= 80 & thresholds$dist_to_infest_km[i] <= 160) {
      thresholds$dist_threshold_km[i] = "Moderate"
  } else if (thresholds$dist_to_infest_km[i] < 80) {
      thresholds$dist_threshold_km[i] = "High"
  } else {
      thresholds$dist_threshold_km[i] = "Out of range"
  }
}


## Loop through risk categories to determine overall risk
for (i in 1:nrow(thresholds)) {
  if (sum(str_detect(thresholds[i,15:19], "Low")) > 0) {
    thresholds$overall_risk[i] = "Low"
  } else if ((sum(str_detect(thresholds[i,15:19], "Low")) == 0) & 
             (sum(str_detect(thresholds[i,15:19], "Moderate")) > 0)) {
      thresholds$overall_risk[i] = "Moderate"
  } else if (sum(str_detect(thresholds[i,15:19], "High")) == 5) {
     thresholds$overall_risk[i] = "High"
  } else {
    thresholds$overall_risk[i] = "ERROR"
  }
}

## Loop through risk categories to determine overall risk without considering distance to nearest infestation
for (i in 1:nrow(thresholds)) {
  if (sum(str_detect(thresholds[i,15:18], "Low")) > 0) {
    thresholds$overall_risk_nodist[i] = "Low"
  } else if ((sum(str_detect(thresholds[i,15:18], "Low")) == 0) & 
             (sum(str_detect(thresholds[i,15:18], "Moderate")) > 0)) {
      thresholds$overall_risk_nodist[i] = "Moderate"
  } else if (sum(str_detect(thresholds[i,15:18], "High")) == 4) {
     thresholds$overall_risk_nodist[i] = "High"
  } else {
    thresholds$overall_risk_nodist[i] = "ERROR"
  }
}


## Generate infestation status
for (i in 1:nrow(thresholds)) {
  if (thresholds$infest_status[i] == 1) {
    thresholds$infestation[i] = "Infested"
  } else {
    thresholds$infestation[i] = "Not infested"
  }
}

counts=thresholds %>% group_by(overall_risk,overall_risk_nodist) %>% summarise(count = n())

###Risk table
kable(thresholds[,c(1,15:22)],col.names=c("Reservoir","Mean summer temp risk threshold","pH risk threshold","Hardness risk threshold","Calcium risk threshold","Distance risk threshold","Overall risk", "Overall risk without distance","Infestation status"),align="c") %>% kable_styling()%>% 
 scroll_box(width = "1000px", height = "500px")%>% row_spec(0, bold = T, font_size = 16, align="c",extra_css = "border-bottom: 1px solid;")

```

<br> <br>

```{r}
## Bind threshold data to geo data
thresh_geo <- left_join(res_center, thresholds, join_by(name))

## Re-level factors
thresh_geo$overall_risk <- factor(thresh_geo$overall_risk, 
                                  levels = c("High", "Moderate", "Low"))

## plot data
ggplot() +
  geom_polygon(data = state_map, aes(x=long,y=lat,group=group), inherit.aes=F, 
     colour='black', fill=NA) +
  geom_sf(data = thresh_geo, aes(color = overall_risk)) +
  scale_color_manual(values = c("Low" = "#44AA99", "Moderate" = "#DDCC77", "High" = "#882255"),
                     name = "Risk of Dreissenid infestation") +
  labs(title = "Dreissenid invasion risk in USACE reservoirs") +
  theme_void()
```

Figure 2. Locations of low, moderate, and high risk reservoirs for dreissenid infestation. Risk was based on mean summer temperatures, total water hardness, water pH, and distance to the nearest infestation

<br>
<br>

Since distance to infestation is likely to change over time as Dreissenids become established in new locations, we also assessed whether risk status changed if distance was not considered as a risk factor. Not considering distance resulted in 26 reservoirs with a low overall risk being elevated to high risk, and an additional 15 being elevated to moderate risk. Additionally, 19 reservoirs that were initially considered moderate risk based on distance to infestation were elevated to high risk.
<br>

```{r}
## Re-level variables
thresh_geo$overall_risk_nodist <- factor(thresh_geo$overall_risk_nodist, 
                                  levels = c("High", "Moderate", "Low"))

## Plot graph
ggplot() +
  geom_polygon(data = state_map, aes(x=long,y=lat,group=group), inherit.aes=F, 
     colour='black', fill=NA) +
  geom_sf(data = thresh_geo, aes(color = overall_risk_nodist)) +
  scale_color_manual(values = c("Low" = "#44AA99", "Moderate" = "#DDCC77", "High" = "#882255"),
                     name = "Risk of Dreissenid infestation") +
  labs(title = "Dreissenid invasion risk in USACE reservoirs without\nconsidering distance to nearest invasion") +
  theme_void()

```

Figure 3. Location of low, moderate, and high risk reservoirs for Dreissenid infestation when not considering distance to nearest infestation as a risk factor. Risk was based on mean summer temperature, total water hardness, calcium concentration, and pH. Low risk reservoirs in Arkansas and North Carolina/Georgia are caused by potentially unsuitable water chemistry. One reservoir in Arizona is considered unsuitable because of summer temperatures.

<br> <br>

Table 4. Number of Dreissenid infested and un-infested reservoirs characterized as low, moderate, or high risk of invasion based on environmental characteristics.

```{r warning=FALSE,message=FALSE}

## Examine how risk category for each variable relates to infestation status

## Mean temperature
mean_temp = thresholds %>% group_by(mean_sum_temp_threshold,infestation) %>% summarise(count = n()) %>%
  pivot_wider(names_from = mean_sum_temp_threshold, values_from = count) %>% mutate(var = "Mean temperature") %>% mutate(Moderate = NA)

## pH
pH = thresholds %>% group_by(pH_threshold,infestation) %>% summarise(count=n()) %>%
  pivot_wider(names_from = pH_threshold, values_from = count) %>% mutate(var = "pH")

## Hardness
hardness = thresholds %>% group_by(hardness_threshold,infestation) %>% summarise(count = n()) %>%
  pivot_wider(names_from = hardness_threshold, values_from = count) %>% mutate(var = "Hardness")

## Calcium
calcium = thresholds %>% group_by(calcium_threshold,infestation) %>% summarise(count = n()) %>%
  pivot_wider(names_from = calcium_threshold, values_from = count) %>% mutate(var = "Calcium")

## Distance
distance = thresholds %>% group_by(dist_threshold_km,infestation) %>% summarise(count=n()) %>%
  pivot_wider(names_from = dist_threshold_km, values_from = count) %>% mutate(var = "Distance to nearest infestation")

## Combine into a single table
risk=rbind(mean_temp,pH,hardness,calcium,distance)

## Replace NAs with zeroes
risk$Moderate=risk$Moderate %>% replace_na(0)
risk$Low=risk$Low %>% replace_na(0)
risk$High=risk$High %>% replace_na(0)

## Re-arrange order of columns
risk=risk[,c(4,1,3,5,2)]

## Display results in table format
kable(risk,col.names = c("Environmental variable","Infestation status","Low risk of invasion","Moderate risk of invasion", "High risk of invasion"),align = "c") %>% kable_styling() %>% collapse_rows(columns = 1,valign="top") %>% row_spec(0, bold = T, font_size = 16, align = "c",extra_css = "border-bottom: 1px solid;") %>% row_spec(10, extra_css = "border-bottom: 1px solid;") %>% column_spec(1,extra_css = "border-bottom: 1px solid;") %>% row_spec(c(2,4,6,8,10),extra_css = "border-bottom: 1px solid") %>% scroll_box(width = "1000px", height = "500px")
```

<br> <br> <br>

```{r warning=FALSE, message=FALSE,fig.height=30,fig.width=45}

## Graph low, moderate, and high risk according to infested and uninfested

## Change data format to longer
risk_long=risk %>% pivot_longer(cols=c("Low","Moderate","High"),names_to = "Risk_level")

risk_long$order=c(1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3)

risk_long %>% ggplot(aes(fill=infestation,y=value,x=reorder(Risk_level,order)))+ geom_bar(position="dodge",stat="identity")+facet_wrap(~var,ncol=3,nrow=2)+labs(x="Risk level",y="Number of reservoirs")+ theme(text=element_text(size=50))+scale_fill_manual(values=c("navyblue","orchid"),name="Infestation status")

```

Figure 4. Number of Dreissenid infested and un-infested USACE reservoirs falling into each risk category (low, moderate, or high) for specified variables.

<br> <br>

Table 5. Percent of USACE reservoirs falling into each risk category for Dreissenid infestation.

```{r warning=FALSE, message=FALSE}

## Summarise percent of reservoirs in each risk category
overall_risk_pct=thresholds %>% group_by(overall_risk) %>% summarise(pct = round(n()/352*100,2)) %>% pivot_wider(names_from = overall_risk, values_from = pct)

overall_risk_pct = overall_risk_pct[,c(2,3,1)]

kable(overall_risk_pct,align = "c",col.names = c("Low risk (%)","Moderate risk (%)", "High risk (%)")) %>% kable_styling() %>% row_spec(0, bold = T, font_size = 16, align = "c",extra_css = "border-bottom: 1px solid;") %>% row_spec(1, extra_css = "border-bottom: 1px solid;")

```

<br> <br>

Table 6. Number of Dreissenid infested or un-infested reservoirs categorized as low, moderate, or high risk for Dreissenid invasion based on factors including mean summer temperature, pH, hardness, and distance to other infested water bodies.

```{r warning=FALSE, message=FALSE}

## Summarise number of infested and uninfested lakes in each risk category
overall_risk = thresholds %>% group_by(overall_risk,infestation) %>% summarise(count = n()) %>% pivot_wider(names_from = overall_risk, values_from = count)

overall_risk = overall_risk[,c(1,3,4,2)]

overall_risk$Low=overall_risk$Low %>% replace_na(0)

kable(overall_risk,align = "c",col.names = c("Infestation status","Low risk","Moderate risk", "High risk")) %>% kable_styling() %>% row_spec(0, bold = T, font_size = 16, align = "c",extra_css = "border-bottom: 1px solid;") %>% row_spec(2, extra_css = "border-bottom: 1px solid;")

```


<br>
<br>

```{r warning=FALSE, message=FALSE,fig.height=25,fig.width=45}

## Graph low, moderate, and high risk according to infested and uninfested

## Change data format to longer
overall_risk_long = overall_risk %>% pivot_longer(cols = c("Low","Moderate","High"),names_to = "Risk_level")

overall_risk_long$order = c(1,2,3,1,2,3)

overall_risk_long %>% ggplot(aes(fill = infestation,y = value,x = reorder(Risk_level,order))) + geom_bar(position = "dodge",stat = "identity") + labs(x = "Risk level", y = "Number of reservoirs") + theme(text = element_text(size = 80)) + scale_fill_manual(values = c("navyblue","orchid"),name = "Infestation status")

```

Figure 5. Number of USACE reservoirs falling into each overall risk category that are infested or un-infested with Dreissenids.

<br>
<br>
Based on our risk categories, approximately 59% of high risk reservoirs have already recorded Dreissenid presence. Interestingly, approximately 27% of moderate risk reservoirs have also recorded Dreissenid presence. These reservoirs were ranked as moderate risk based on pH (n=14) or distance to nearest infestation (n=2). Most of the reservoirs limited by pH were located in the Arkansas River drainage or in the Black-Warrior Tombigbee system in Alabama. One pH-limited reservoir was located in Pennsylvania (Curwensville Lake) and the two distance limited reservoirs were in Iowa and North Dakota. With the exception of Curwensville Lake (Pennsylvania), Oliver Lake (Alabama), and Rathbun Lake (Iowa), all invaded moderate risk reservoirs have established Dreissenid populations, with some having been invaded as early as the 1990s. This could suggest that 1) more fine scale environmental data may be required to understand how intra-reservoir variation in environmental characteristics such as underlying geology could contribute to suitable conditions in reservoirs, or 2) that Dreissenids may be more tolerant of pH than expected. For the three remaining lakes where invasion status is unknown but positive Dreissenid records have occurred, it is possible that Dreissenids have been introduced to these reservoirs but have not been able to establish strong populations due to sub-optimal environmental conditions. For reservoirs with a moderate risk of invasion based on distance to the next nearest positive record, it is possible that Dreissenids were transported long distances by boaters given that few source populations were present nearby to fuel population expansion into these areas. Both lakes limited by distance were classified as high risk when excluding distance as a risk factor.

<br>
<br>
```{r warning=FALSE, message=FALSE}

## Summarise moderate risk lakes
## Load moderate reservoirs that are infested
mod_infest = thresholds %>% filter((pH_threshold == "Moderate" | dist_threshold_km == "Moderate") & infest_status == 1)


kable(mod_infest[,c(1,15:22)],col.names=c("Reservoir","Mean summer temp risk threshold","pH risk threshold","Hardness risk threshold","Calcium risk threshold","Distance risk threshold","Overall risk", "Overall risk without distance","Infestation status"),align="c") %>% kable_styling()%>% 
 scroll_box(width = "1000px", height = "500px")%>% row_spec(0, bold = T, font_size = 16, align="c",extra_css = "border-bottom: 1px solid;")

```
<br>
<br>


```{r warning=FALSE, message=FALSE}

## Create empty column to store which variable is of moderate risk
mod_infest$risk_var = NA

## Assign risk variables
mod_infest$risk_var[which(mod_infest$pH_threshold == "Moderate")] = "pH"
mod_infest$risk_var[which(mod_infest$dist_threshold_km == "Moderate")] = "Distance to nearest infestation"

res_mod_infest = res_raw %>% filter(name %in% mod_infest$name)

## Get centers of lakes
res_center = st_centroid(res_mod_infest) %>% 
  select(name)

res_center_mod = left_join(res_center, mod_infest, join_by(name))

## Plot data
ggplot() +
  geom_polygon(data = state_map, aes(x = long,y = lat,group = group), inherit.aes = F, 
     colour = 'black', fill = NA) +
  geom_sf(data = res_center_mod, aes(color = as.factor(risk_var))) +
  scale_color_manual(values = c("pH" = "navyblue", "Distance to nearest infestation" = "orchid"), 
                     labels = c("pH" = "pH", "Distance to nearest infestation" = "Distance to nearest infestation"),
                     name = "Dreissenid Presence") +
  labs(title = "Dreissenid presence in moderate risk USACE reservoirs") +
  theme_void()
```

<br>
Figure 6. Location of USACE reservoirs with moderate invasion risk based on pH or distance to nearest infestation that have positive Dreissenid occurrences according to NAS (Benson et al. 2024).

# Data analysis

Next, we used the data available on a national scale to try to better understand how different environmental and social factors may be related to Dreissenid presence in USACE reservoirs. We explored several analysis methods to investigate our questions, which are outlined below:

<br> <br>

## Correlation Matrices

Before we used any predictive models to evaluate the risk of dreissenid mussel invasion, we wanted to understand how correlated different variables are. When variables are correlated they may not be suited for certain types of modeling, like logistic regression. In the below figures, bigger, darker blue dots indicate that two variables are positively correlated, while bigger, darker red dots indicate a negative correlation.

Figure 6. A correlation plot showing how correlated different land-use variables are. All urban land-use categories are positively correlated, while forested land is negatively correlated with herbaceous cover and crop cover.

```{r}
landuse <- ZQM_data %>% 
  select(perc_open_water_50mi, perc_dev_openspace_50mi: perc_wetland_50mi)

m = cor(landuse, use = "complete.obs")

corrplot(m, method = "circle", type = "upper",
         title = "correlation between land-use categories", 
         mar=c(0,0,2,0),
         diag=FALSE)
```

Figure 7. A correlation plot showing how correlated different water chemistry and geology variables are. There are no stron correlations among these variables.

```{r}
water_chem <- ZQM_data %>% 
  select(max_Ca, max_pH, max_hardness, c(perc_alluvial_25mi:perc_resid_volcanic_art_wat_25mi))

m = cor(water_chem, use = "complete.obs")

corrplot(m, method = "circle", type = "upper", 
         title = "correlation between water chemestry and geology variables",
         mar=c(0,0,2,0))
```

Figure 8. A correlation plot showing how correlated different climate variables are. Temperatures are all very correlated.

```{r}
climate_cor <- ZQM_data %>% 
  select(winter_total_precip:fall_max_temp)

m = cor(climate_cor, use = "complete.obs")

corrplot(m, method = "circle", type = "upper", 
         title = "Correlation between climate variables",
         mar=c(0,0,2,0))
```

Figure 9. A correlation plot showing how correlated seasonal NDCI variables are. Seasonal mean NDCI values are somewhat correlated with all NDCI variables.

```{r}
ndci_cor <- ZQM_data %>% 
  select(mean_ndci_fall:max_ndci_winter)

m = cor(ndci_cor, use = "complete.obs")

corrplot(m, method = "circle", type = "upper", 
         title = "Correlation between seasonal NDCI values",
         mar=c(0,0,2,0))
```

Figure 10. A correlation plot showing how correlated surface area, distance to infestation, and visitation variables are. There are no strong correlations between the three variables.

```{r}
rec <- ZQM_data %>% 
  select(dist_to_infest_km, surface_area_km, mean_total_visits)

m = cor(rec, use = "complete.obs")

corrplot(m, method = "circle", type = "upper", 
         title = "Correlation between visits, surface area, and distance to infestation",
         mar=c(0,0,2,0))
```

Figure 11. A correlation plot showing how correlated the variables that determine our risk categories are. There are no strong correlations among these variables

```{r}
risks <- ZQM_data %>%  
  select(dist_to_infest_km, summer_mean_temp, max_Ca,
         max_pH, max_hardness)

m = cor(risks)

corrplot(m, method = "circle", type = "upper", 
         title = "Correlation between main risk variables",
         mar=c(0,0,2,0))
```

## Logistic regressions

We ran several exploratory logistic regression models using binary infested (1) versus not infested (0) as the outcome variable. We used different input variables in each logistic regression. Our goal was not to predict Dreissenid infestation, but rather to identify significant environmental predictors and the directionality of their influence.

We used the Akaike Information Criterion or AIC value to evaluate the quality of each model. The AIC value looks at the predictive power of the model as well as the number of inputs in each model. Generally, fewer inputs are better, because it reduces the chance of the model over fitting to the data. There is no goal AIC value, rather comparatively lower AIC values indicate a better quality model compared to models with higher AIC values.

To assess the significance of each input we used the p value. The smaller the p value, the lower the chance that the input variable has no influence on the response variable. A p value of under 0.05 is indicated by a period, and anything smaller than that is indicated by one or more asterisks.

To evaluate the directionality of influence, we examined the coefficient value. The coefficient value indicates the change in log odds that the response variable will be 1 if the input variable increases by one unit.In our case, it indicates the log odds that a reservoir will be infested if the predictor variable is increased by one unit. Coefficients should only be evaluated if the model is of good quality and if the p value for the input value is very low.

<br> <br>

### Landcover

We ran a logistic regression with the percent of land dedicated to each land-use category within a 25 and 50 mile buffer of each reservoir as input variables. Data was from the NLCD.

First we ran the model with a 50 mile buffer for each land cover category.

Note that the model did not converge with percent perennial snow and ice included in the logistic regression.

Below is the model summary. The coefficient name (or input variable name) is in the first column on the left. The next column over, called `Estimate`, contains the coefficient value with tells you the directionality of influence that the coefficient has on the outcome variable. The column with the p value is on the far right. the AIC value is stated below the table output.

```{r}
#some data cleaning
landcover_50  <- ZQM_data %>%
  select(infest_status, c(perc_open_water_50mi, perc_dev_openspace_50mi: perc_wetland_50mi)) %>% 
  mutate(infest_status = as.factor(infest_status))

#run the model
landcover_50_logit <- glm(infest_status ~ ., data = landcover_50, family = "binomial")

#print model summary
summary(landcover_50_logit)
```

Notes: In this model, there are no significant predictors of infestation.

We then ran the model with a 25 mile buffer. Note that the model also did not converge with percent open water or percent snow and ice variables included.

```{r}
#some data cleaning
landcover_25  <- ZQM_data %>%
  select(infest_status, c(perc_dev_openspace_25mi: perc_wetland_25mi)) %>% 
  mutate(infest_status = as.factor(infest_status))

#run the model
landcover_25_logit <- glm(infest_status ~ ., data = landcover_25, family = "binomial")

#print model summary
summary(landcover_25_logit)
```

Notes: When we ran the model with a 25 mile buffer, it showed barren land, forest cover, shrub cover, herbaceous cover, hay pasture cover, crop cover, and wetland cover to be significant predictors of infestation. Barren land has a slight positive influence on infestation, while all other significant variables are negatively associated with infestation. The model did not show any development categories to be significant. While this model does have a lower AIC value than the previous model, it still is not very low so this model is not the best quality.

In the next model, we aggregate all development classifications into a single category, again using the 25 mile buffer.

```{r}
#looking at what happens when development landcovers are summed
dev_sum <- ZQM_data %>% 
  mutate(dev_sum_25mi = perc_dev_openspace_25mi + perc_dev_lowintensity_25mi + perc_dev_medintensity_25mi + perc_dev_highintensity_25mi) %>% 
  select(dev_sum_25mi, infest_status, c(perc_barren_25mi:perc_wetland_25mi)) %>% 
  mutate(infest_status = as.factor(infest_status))

#run new model
dev_sum_25_logit <- glm(infest_status ~ ., data = dev_sum, family = "binomial")

#summarise new model
summary(dev_sum_25_logit)
```

Notes: The model showed all variables to be significant. Percent barren land has a postive relationship with infestation, while all other variables have a negative relationship with infestation. Of all landuse logistic regressions, this one has the lowest AIC score. <br> <br>

### Water chemistry and geology

Next we ran a logistic regression with various water chemistry and geology characteristics as predictors. Note that many water chemistry variables are likely correlated, which is not ideal for logistic regression. This model is for exploratory purposes only. For hardness, we used the midpoint of the given range of values. Below is the model summary.

```{r}
#looking at geology and water chemistry
water_chem <- ZQM_data %>% 
  select(infest_status, max_Ca, max_pH, max_hardness, c(perc_alluvial_25mi:perc_resid_volcanic_art_wat_25mi)) %>% 
  mutate(infest_status = as.factor(infest_status))

#run the model
water_chem_logit <- glm(infest_status ~ ., data = water_chem, family = "binomial")

#print summary
summary(water_chem_logit)
```

Notes: This model seems to indicate that pH and calcium content are statistically significant predictor of infestation. Increases in pH and calcium are associated with increases in the risk of infestation. This model has a comparatively higher AIC score, indicating poor model performance. <br>
<br>

### Climate

We also ran a logistic regression with various climate variables as predictors. Note that climate variables are likely all correlated, which is not ideal for logistic regression. This model is for exploratory purposes only.

```{r}
#looking at climate
climate <- ZQM_data %>% 
  select(infest_status, c(winter_total_precip:fall_max_temp)) %>% 
  mutate(infest_status = as.factor(infest_status))

#run the model
climate_logit <- glm(infest_status ~., data = climate, family = "binomial")

#print model summary
summary(climate_logit)
```

Notes: This model shows many temperature variables as being significant, and also summer and winter precipitation. The AIC value for this model is comparatively lower than models we examined previously.

We also ran a logistic regression with just total precipitation and summer mean temperature, to simplify the number of variables and eliminate highly correlated variables.

```{r}
#looking at just mean temps
mean_temp <- climate %>% 
  mutate(total_precip = winter_total_precip + spring_total_precip + summer_total_precip + fall_total_precip) %>% 
  select(infest_status, total_precip, summer_mean_temp) %>% 
  mutate(infest_status = as.factor(infest_status))

#run model with mean temps
mean_temp_logit <- glm(infest_status ~., data = mean_temp, family = "binomial")

#print model summary
summary(mean_temp_logit)
```

Notes: When looking at total precipitation and mean summer temperature, only mean summer temperature is significant. This model has a higher AIC value compared to the previous climate model. 

<br> <br>

### Size, recreation, and connectivity

```{r, warning=FALSE}
## Looking at proximity to water bodies, connection status, etc
connectivity <- ZQM_data %>% 
  select(infest_status, dist_to_infest_km, surface_area_km, connectivity, mean_total_visits) %>% 
  mutate(infest_status = as.factor(infest_status))

#set factor levels for connectivity
connectivity$connectivity <- factor(connectivity$connectivity, levels = c("None", "Dam", "Lock and Dam"))

#run model
connect_logit <- glm(infest_status ~., data = connectivity, family = "binomial")

#print model summary
summary(connect_logit)
```

Notes: distance to infestation is the most significant predictor, and surface area is also significant. Increasing distance has a negative relationship with infestation while increasing surface area has a slight positive relationship with infestation. Connectivity is also significant. Reservoirs with a lock and dam are more likely to be infested than those with just a dam or no connection. This model has lowest AIC so far, indicating better predictive power when compared with the previous logistic regression models.

### Previously identified risk variables

Next we will run a logistic regression using all the variables we used to classify risk. These are variables that have been identified as potentially limiting to dreissenid mussels in the literature. The variables are distance to infestation, mean hardness, average calcium content, average pH and mean summer temperature.

```{r, message=FALSE, warning=FALSE}
## Looking at proximity to water bodies, connection status, etc
risk_vars <- ZQM_data %>% 
  select(infest_status, dist_to_infest_km, summer_mean_temp, max_Ca,
         max_pH, max_hardness) %>% 
  mutate(infest_status = as.factor(infest_status))

#run model
risk_logit <- glm(infest_status ~., data = risk_vars, family = "binomial")

#print model summary
summary(risk_logit)
```

Notes: Distance to infestation is significant and negatively associated with infestation. Mean summer temperature is significant and positively associated with infestation. All other input variables are not significant. This model has a low AIC, but it is slightly higher than the size, recreation, and connectivity logistic model.

## Gradient boosted model

A gradient boosted model (GBM) is a flexible machine learning algorithm that is immune to issues caused by multicollinearity. It works by combining multiple weak models (think small decision trees) into one strong model.

In this instance, we split the data into training data to train the model and testing data to test the model. Since there is so little data, taking even a few observations away to later test the model may impact the model training.

We made the following modifications to the data to reduce the number of inputs.

-   We used percent land-use within 25 miles and dropped percent land-use within 50 miles. We also combined all development categories into one category.

-   We calculated total annual precipitation and used that and summer mean temperature from the climate data.

-   We used only summer mean NDCI

-   We used average calcium, average pH, and average hardness as water chemistry inputs

Below is a summary of the model, trained using the training data.

```{r warning=FALSE,message=FALSE,fig.height=20,fig.width=20,attr.output='style="max-height: 500px;"'}
library(gbm) #for gradient boosting models
library(Metrics) #for RMSE calculation
library(rsample) #for splitting data into test and training

#prepare data for gradient boosted tree
boosted_data <- ZQM_data %>% 
  mutate(dev_sum_25mi = perc_dev_openspace_25mi + perc_dev_lowintensity_25mi + perc_dev_medintensity_25mi + perc_dev_highintensity_25mi) %>% 
  mutate(total_precip = winter_total_precip + spring_total_precip + summer_total_precip + fall_total_precip) %>% 
  select(dist_to_infest_km: num_connections,
         perc_open_water_25mi, dev_sum_25mi, perc_barren_25mi:perc_crops_25mi,
         mean_elev_m:perc_resid_volcanic_art_wat_25mi,
         max_hardness,
         total_precip,
         summer_mean_temp,
         mean_ndci_summer,
         mean_total_visits, 
         max_Ca,
         max_pH,
         infest_status) %>% 
  mutate(connectivity = as.factor(connectivity)) %>% 
  mutate(infest_status = as.numeric(infest_status))

#set factor levels for connectivity
boosted_data$connectivity <- factor(boosted_data$connectivity, levels = c("None", "Dam", "Lock and Dam"))

#define split parameters
boosted_data_split <- boosted_data %>% 
  initial_split(prop = 0.8, strata = infest_status)

#write split data to data frames
train_split <- training(boosted_data_split)
test_split <- testing(boosted_data_split)

#run model
infest_gbm = gbm(infest_status ~ ., 
                 distribution = "bernoulli",
                 data = train_split,
                 n.trees = 1000,
                 shrinkage = 0.01,
                 interaction.depth = 4)
#print model
infest_gbm
```

Below is a list of the most influential variables, according to the gradient boosted model. Variables with a higher `rel.inf`are more influential in the model outcome. Note that the influence value is meant to be interpreted relative to other influence values. Even though predictions generated using GBM models are not affected by multicollinearity, if two variables are highly correlated, the influence will be split between them.

```{r warning=FALSE,message=FALSE,fig.height=20,fig.width=20,attr.output='style="max-height: 500px;"'}
#the model summary
summary(infest_gbm, plotit = F)
```

Note: Distance to infestation is vastly more influential than other predictors.

It is also possible to see the general relationship between the predictor variables and the outcome variable. Below are figures showing the relationship between infestation on the Y axis (recall 0 indicates not infested and 1 indicates infested) and the predictor variable on the X axis. Note the different axis values between plots.

```{r}
#plot some rough graphs showing relationship between infestation and key vars
plot(infest_gbm,i="dist_to_infest_km", type = "response")
```

Figure 12. There is a negative relationship between infestation and the distance to the nearest infected body of water. Infestation is much more likely when other infestations are close.

```{r}
plot(infest_gbm,i="max_Ca", type = "response") 
```

Figure 13: There is a positive relationship between observed average calcium levels and infestation status.

```{r}
plot(infest_gbm,i="surface_area_km", type = "response") 
```

Figure 14. There is a positive relationship between infestation and the size of the reservoir. Larger reservoirs are more likely to be infested.

```{r}
plot(infest_gbm,i="summer_mean_temp", type = "response") 
```

Figure 15. There is a positive relationship between summer mean temperatures and infestation status.

<br> <br>

Next we use the model to generate predictions. We will then create a confusion matrix and calculate RMSE. A confusion matrix shows the number of true negatives (top left value), false negatives (top right), false positives (bottom left), and true positives (bottom right). RMSE stands for Root Mean Squared Error. A smaller RMSE indicates the model is more accurate.

Below is a confusion matrix for the training data.

```{r, message=FALSE}
#generating predictions for training data
train_preds <- predict.gbm(infest_gbm, newdata = train_split, type="response")

#converting to 0,1 outcome
train_pred_class <- ifelse(train_preds > 0.5, 1, 0)

#creating confusion matrix
confusionMatrix(as.factor(train_pred_class), 
                as.factor(train_split$infest_status),
                positive = '1')
```

Below is the RMSE for the training data

```{r, message=FALSE}
#create predictions
predictions_training <- predict(infest_gbm, newdata = train_split, type = "response")

#calculate RMSE for training data
Metrics::rmse(predictions_training, train_split$infest_status)
```

Below is a confusion matrix for the test data.

```{r, message=FALSE}
#testing model
test_preds <- predict.gbm(infest_gbm, newdata = test_split, type="response")

test_pred_class <- ifelse(test_preds > 0.5, 1, 0)

confusionMatrix(as.factor(test_pred_class), 
                as.factor(test_split$infest_status),
                positive = '1')
```

Below is RMSE for the test data.

```{r, message=FALSE}
#create predictions
predictions_test <- predict.gbm(infest_gbm, newdata = test_split, type = "response")

#calculate RMSE for training data
Metrics::rmse(predictions_test, test_split$infest_status)
```

The shows some signs of overfitting. It "predicts" infestation with perfect accuracy when given the training data, but it is less accurate when predicting infestation with new data. Still, the model is reasonably effective and may be further improved with model tuning.

<br> <br>

## Random forest analysis

Random forest classification is a type of machine learning that functions similarly to classification and regression tree analysis (CART). Random forest analysis does not assume linearity, normality, or homoscedasticity and is less sensitive to spatial autocorrelation and multicollinearity.

Random forest classification works by generating a series of bootstrapped trees that have low correlation with one another and averaging the results of these individual trees across a "forest" of many trees to prevent overfitting. Individual trees are created by randomly selecting a subset of all possible variables and using them to build and test a classification scheme using randomly selected training (64%) and test data (36%). Since each tree uses a random subset of variables and different training and test data, they should be relatively different from one another.

We can evaluate the performance of the random forest classification by obtaining an estimate of out-of-bag (OOB) error, which describes the overall percentage of incorrectly categorized data (in this case presence versus absence), averaged across trees.

We used the 'randomForest' package in R to run this analysis (Liaw and Wiener, 2002).

We obtained several outputs from the random forest classification, including:


1)  Accuracy: overall accuracy of classification (average % of time random forest correctly classifies records)
2)  Confidence interval: The 95% confidence interval for the accuracy rate
3)  No information rate: The accuracy of the model if we were to assign all reservoirs a value of zero without running a classification
4)  P-value (Acc > NIR): Indicates whether your model accuracy is significantly higher than your no information rate, which is an indication that your model provides valuable information
5)  McNemar's test p-value: This test statistic serves to test whether the counts of false positives in the model are significantly different from the counts of false negatives.If the p-value of the test is significant, than we can say relatively confidently that the model has a different proportion of false positives and false negatives. McNemar's test compares the relative difference in the relative proportion of error between the two rather than the difference in error itself
6)  Sensitivity: The probability that an infested reservoir will be correctly classified as infested
7)  Specificity: The probability that an uninfested reservoir will be correctly classified as uninfested
8)  Pos pred value: The proportion of true positives captured by the total number of predicted positives
9)  Neg pred value: The proportion of true negatives captured by the total number of predicted negatives
10) Prevalence: The rate of all true positives in the whole population (The actual prevalence of infestations across reservoirs, regardless of classification)
11) Detection rate: The rate of detected true positives in the whole population (how many infested reservoirs are categorized as infested)
12) Detection prevalence: The rate of predicted positives in the whole population (how many reservoirs are predicted to be infested based on the classification)
13) Balanced accuracy: The average of sensitivity and specificity scores
14) Positive class: The class identified as indicating a 'positive' record (i.e., Dreissenid presence)
15) Importance: The average decrease in model accuracy if a given variable were dropped from the analysis

To run our random forest classification, we created 1000 trees using the default settings, including:

mtry: number of variables randomly sampled as candidates at each split (sqrt(p) by default, where p is the number of variables).

nodesize: minimum size of terminal nodes (1 by default)

To account for highly correlated variables, which can affect variable importance scores in the random forest model, we identified any variables with a correlation coefficient higher than 0.8 and retained only one variable from each of these groups. For LULC, we retained data for 25 mile buffers over 50 mile buffers given their better performance in the logistic regressions. For water quality data, we retained maximum values over average values because they performed better when classifying reservoir invasion risk. For developed land cover, we summed development categories based on logistic regression performance

### Random forest with test and training datasets

Below is a random forest model trained with the same training data given to the gradient boosted model. First the variable importance is displayed:

```{r, fig.height = 15,fig.width=15}
## Random forest with training and test datasets

## Sum development land covers
train_split = train_split %>% 
  mutate(dev_sum_25mi = perc_dev_openspace_25mi + perc_dev_lowintensity_25mi + perc_dev_medintensity_25mi + perc_dev_highintensity_25mi)

test_split = test_split %>% 
  mutate(dev_sum_25mi = perc_dev_openspace_25mi + perc_dev_lowintensity_25mi + perc_dev_medintensity_25mi + perc_dev_highintensity_25mi)

## Remove highly correlated variables
train_split = train_split %>% select(-c(surface_ar,perc_dev_openspace_50mi,
                      perc_dev_medintensity_25mi,perc_dev_highintensity_25mi,
                      perc_dev_lowintensity_50mi,perc_dev_medintensity_50mi,
                      perc_dev_highintensity_50mi,perc_dev_openspace_25mi,
                      perc_dev_lowintensity_25mi,perc_forest_50mi,
                      perc_shrubscrub_50mi,perc_herbaceous_50mi,perc_haypasture_50mi,
                      perc_crops_50mi,perc_wetland_50mi,fall_total_precip,
                      avg_Ca,min_Ca,avg_pH,min_pH,spring_mean_temp,fall_mean_temp,
                      winter_min_temp,spring_min_temp,fall_min_temp,winter_max_temp,
                      spring_max_temp,fall_max_temp,winter_mean_dewp,spring_mean_dewp,
                      winter_max_vpd,summer_min_temp,summer_max_temp,fall_mean_dewp,
                      summer_mean_dewp,summer_max_vpd,fall_max_vpd,spring_min_vpd,
                      fall_min_vpd,winter_mean_temp,winter_min_vpd,summer_min_vpd,
                      spring_max_vpd,mean_ndci_fall,mean_ndci_spring,mean_ndci_winter,
                      max_ndci_fall,max_ndci_fall,max_ndci_spring,max_ndci_summer,
                      min_ndci_fall,min_ndci_spring,min_ndci_summer,min_ndci_winter))

test_split = test_split %>% select(-c(surface_ar,perc_dev_openspace_50mi,
                      perc_dev_medintensity_25mi,perc_dev_highintensity_25mi,
                      perc_dev_lowintensity_50mi,perc_dev_medintensity_50mi,
                      perc_dev_highintensity_50mi,perc_dev_openspace_25mi,
                      perc_dev_lowintensity_25mi,perc_forest_50mi,
                      perc_shrubscrub_50mi,perc_herbaceous_50mi,perc_haypasture_50mi,
                      perc_crops_50mi,perc_wetland_50mi,fall_total_precip,
                      avg_Ca,min_Ca,avg_pH,min_pH,spring_mean_temp,fall_mean_temp,
                      winter_min_temp,spring_min_temp,fall_min_temp,winter_max_temp,
                      spring_max_temp,fall_max_temp,winter_mean_dewp,spring_mean_dewp,
                      winter_max_vpd,summer_min_temp,summer_max_temp,fall_mean_dewp,
                      summer_mean_dewp,summer_max_vpd,fall_max_vpd,spring_min_vpd,
                      fall_min_vpd,winter_mean_temp,winter_min_vpd,summer_min_vpd,
                      spring_max_vpd,mean_ndci_fall,mean_ndci_spring,mean_ndci_winter,
                      max_ndci_fall,max_ndci_fall,max_ndci_spring,max_ndci_summer,
                      min_ndci_fall,min_ndci_spring,min_ndci_summer,min_ndci_winter))

## Train the model

infest_rf = randomForest(as.factor(infest_status) ~ ., #writing the formula
                          data = train_split, #specifying training data to be used
                          mtry = sqrt(length(train_split)-1), #setting number of variables to randomly sample per each split
                          ntree= 1000, #setting number of trees
                          na.action = na.omit, #specifying what to do with NAs
                          importance = TRUE #specifying importance of variables should be assessed
                          )

## Check variable importance
varImpPlot(infest_rf,sort = T,n.var = (length(train_split) - 1),main = "Variable importance plot")

```

Then we will create a confusion matrix for the training data and test its performance for classification:

```{r attr.output='style="max-height: 500px;"'}
#training confusion matrix
p_train <- predict(infest_rf, newdata = train_split)
confusionMatrix(p_train, as.factor(train_split$infest_status),positive = '1')
```

Above, we see that RF model is 100% accurate and the confusion matrix for the training data indicates that all Dreissenid presences and absences are correctly classified. The accuracy rate is statistically significantly higher than the no information rate, and the prevalence and detection rates mirror that of the actual population (~24% of reservoirs have positive records). Next, we will test our model with the testing dataset:

```{r attr.output='style="max-height: 500px;"'}
#test confusion matrix
p_test <- predict(infest_rf, newdata = test_split)
confusionMatrix(p_test, as.factor(test_split$infest_status),positive = '1')

#No RMSE for categorical outcomes in RF

```

<br>
Here, our RF model correctly classifies reservoirs based on Dreissenid presence approximately 81% of the time, although the balanced accuracy is lower (around 70%) because the model's sensitivity is poor. In other words, the model is not very good at accurately recognizing when Dreissenids are present, even though it is fairly good at predicting when Dreissenids are absent (as indicated by the high specificity rate). Furthermore, the accuracy rate is not significantly better than the no information rate, indicating that we could just assign all reservoirs as "absent" and still perform about as well as our model does now. The prevalence of Dreissenids in the test dataset is similar to the whole dataset, but the detection rate and detection prevalence are lower than the true prevalence. Our model may be limited by the "noise" of having so many variables included in it, so we decided to try reducing the number of variables by looking at only the 10 most important variables according to the mean decrease in accuracy metric.
<br>
<br>

## Random forest with reduced variables

```{r}
## Random forest with training and test datasets

train_split_red = train_split %>% select(c(dist_to_infest_km,max_Ca,summer_mean_temp,
                                           winter_total_precip,perc_shrubscrub_25mi,
                                           surface_area_km,perc_forest_25mi,max_pH,
                                           perc_open_water_25mi,summer_total_precip,
                                           infest_status))

test_split_red = test_split %>% select(c(dist_to_infest_km,max_Ca,summer_mean_temp,
                                           winter_total_precip,perc_shrubscrub_25mi,
                                           surface_area_km,perc_forest_25mi,max_pH,
                                           perc_open_water_25mi,summer_total_precip,
                                         infest_status))

## Train the model
rf_ten_vars = randomForest(as.factor(infest_status) ~ ., #writing the formula
                          data = train_split_red, #specifying training data to be used
                          mtry = sqrt(length(train_split_red)-1), #setting number of variables to randomly sample per each split
                          ntree= 1000, #setting number of trees
                          na.action = na.omit, #specifying what to do with NAs
                          importance = TRUE #specifying importance of variables should be assessed
                          )

## Check variable importance
varImpPlot(rf_ten_vars,sort = T,main = "Variable importance plot")
```

<br>
<br>
Next, we will create a confusion matrix for the training data.

```{r attr.output='style="max-height: 500px;"'}
#training confusion matrix
p_train <- predict(rf_ten_vars, newdata = train_split_red)
confusionMatrix(p_train, as.factor(train_split_red$infest_status),positive = '1')
```
Similarly to our RF model with all variables, this RF model is 100% accurate for the training data. Next, we'll see how it performs with the test data:

```{r attr.output='style="max-height: 500px;"'}
#test confusion matrix
p_test <- predict(rf_ten_vars, newdata = test_split_red)
confusionMatrix(p_test, as.factor(test_split_red$infest_status),positive = '1')

#No RMSE for categorical outcomes in RF

```
Removing all but the 10 most influential variables improves the model slightly, but the model accuracy is still not significantly better than the no information rate. We will also try a random forest model containing just the variables used in our risk assessment to see if that improves the performance.

<br>
<br>

## Random forest with risk variables

Next, we will try the random forest using only the variables identified for risk thresholds to see if we can successfully classify reservoirs based on only a few environmental variables. Below, we have the variable importance plot:

```{r}
## Random forest with training and test datasets

train_split_risk = train_split %>% select(c(dist_to_infest_km,max_Ca,max_pH,max_hardness,summer_mean_temp,infest_status))

test_split_risk = test_split %>% select(c(dist_to_infest_km,max_Ca,max_pH,max_hardness,summer_mean_temp,infest_status))

## Train the model
rf_risk_vars = randomForest(as.factor(infest_status) ~ ., #writing the formula
                          data = train_split_risk, #specifying training data to be used
                          mtry = sqrt(length(train_split_risk)-1), #setting number of variables to randomly sample per each split
                          ntree= 1000, #setting number of trees
                          na.action = na.omit, #specifying what to do with NAs
                          importance = TRUE #specifying importance of variables should be assessed
                          )

## Check variable importance
varImpPlot(rf_risk_vars,sort = T,main = "Variable importance plot")
```

<br>
<br>
Next, we will create a confusion matrix for the training data.

```{r attr.output='style="max-height: 500px;"'}
#training confusion matrix
p_train <- predict(rf_risk_vars, newdata = train_split_risk)
confusionMatrix(p_train, as.factor(train_split_risk$infest_status),positive = '1')
```

Similarly to our RF model with all variables, this RF model is 100% accurate for the training data. Next, we'll see how it performs with the test data:

```{r attr.output='style="max-height: 500px;"'}
#test confusion matrix
p_test <- predict(rf_risk_vars, newdata = test_split_risk)
confusionMatrix(p_test, as.factor(test_split_risk$infest_status),positive = '1')

#No RMSE for categorical outcomes in RF

```

Here, we can see that reducing the number of variables in our model incerased the accuracy (~83%) and the balanced accuracy (~74%) of our RF model. However, the model's sensitivity is still relatively poor and our accuracy is not significantly better than the no information rate. One factor that could be contributing to this is that the average temperatures of the reservoirs may not be particularly useful for distinguishing between reservoirs that are at risk of invasion. This is pretty clear in our risk assessment, because only a single reservoir is classified below high risk based on our thresholds. Hence, we decided to also try a Random Forest model without mean summer temperature.

## Random forest with reduced variables no temperature

Since we know we have limited information about duration of temperature stressors, we will also try the random forest using only the variables identified for risk thresholds, but excluding temperature risk thresholds.

```{r}
## Random forest with training and test datasets

train_split_red_temp = train_split %>% select(c(dist_to_infest_km,max_Ca,max_pH,max_hardness,infest_status))

test_split_red_temp = test_split %>% select(c(dist_to_infest_km,max_Ca,max_pH,max_hardness,infest_status))

## Train the model
rf_risk_vars_temp = randomForest(as.factor(infest_status) ~ ., #writing the formula
                          data = train_split_red_temp, #specifying training data to be used
                          mtry = sqrt(length(train_split_red_temp)-1), #setting number of variables to randomly sample per each split
                          ntree= 500, #setting number of trees
                          na.action = na.omit, #specifying what to do with NAs
                          importance = TRUE #specifying importance of variables should be assessed
                          )

## Check variable importance
varImpPlot(rf_risk_vars_temp,sort = T,main = "Variable importance plot")

```

<br> <br> Then we will create a confusion matrix for the training data.

```{r attr.output='style="max-height: 500px;"'}
#training confusion matrix
p_train <- predict(rf_risk_vars_temp, newdata = train_split_red_temp)
confusionMatrix(p_train, as.factor(train_split_red_temp$infest_status),positive = '1')
```

Like all the other models, the RF model performs perfectly on the training data.

```{r attr.output='style="max-height: 500px;"'}
#test confusion matrix
p_test <- predict(rf_risk_vars_temp, newdata = test_split_red_temp)
confusionMatrix(p_test, as.factor(test_split_red_temp$infest_status),positive = '1')

#No RMSE for categorical outcomes in RF

```

When we apply the new RF model to the test data, our accuracy improves even more to around 86%, with a balanced accuracy around 79%. Although the model's sensitivity is still relatively low, here we see that our RF model is significantly better than the no information rate, meaning it contains information that is actually useful.

<br>
<br>

## Random forest with recursive feature elimination

Just to see what happens, we can try recursive feature elimination to see how many and what variables will be included in our model.

```{r}

## Recursive feature elimination
### install.packages("mlbench")

## Set all categorical variables as factors
ZQM[sapply(ZQM, is.character)] <- lapply(ZQM[sapply(ZQM, is.character)], 
                                       as.factor)

## Set infestation status and connectivity as categorical
ZQM$infest_status=as.factor(ZQM$infest_status)
ZQM$connectivity=as.factor(ZQM$connectivity)

## Remove NAs
ZQM=na.omit(ZQM)

## Remove highly correlated variables
ZQM = ZQM %>% select(-c(surface_ar,perc_dev_openspace_50mi,
                      perc_dev_medintensity_25mi,perc_dev_highintensity_25mi,
                      perc_dev_lowintensity_50mi,perc_dev_medintensity_50mi,
                      perc_dev_highintensity_50mi,perc_dev_openspace_25mi,
                      perc_dev_lowintensity_25mi,perc_forest_50mi,
                      perc_shrubscrub_50mi,perc_herbaceous_50mi,perc_haypasture_50mi,
                      perc_crops_50mi,perc_wetland_50mi,fall_total_precip,
                      avg_Ca,min_Ca,avg_pH,min_pH,spring_mean_temp,fall_mean_temp,
                      winter_min_temp,spring_min_temp,fall_min_temp,winter_max_temp,
                      spring_max_temp,fall_max_temp,winter_mean_dewp,spring_mean_dewp,
                      winter_max_vpd,summer_min_temp,summer_max_temp,fall_mean_dewp,
                      summer_mean_dewp,summer_max_vpd,fall_max_vpd,spring_min_vpd,
                      fall_min_vpd,winter_mean_temp,winter_min_vpd,summer_min_vpd,
                      spring_max_vpd,mean_ndci_fall,mean_ndci_spring,mean_ndci_winter,
                      max_ndci_fall,max_ndci_fall,max_ndci_spring,max_ndci_summer,
                      min_ndci_fall,min_ndci_spring,min_ndci_summer,min_ndci_winter))

## Select x variables
env_vars = ZQM %>% select(-c(infest_status))

library(mlbench)

## Define control with a random forest selection function
control = rfeControl(functions = rfFuncs, method = "cv", number = 10)

## Run the RFE algorithm
results = rfe(x = env_vars, y = ZQM$infest_status, rfeControl = control)

## summarize the results
print(results)

## list the chosen features
predictors(results)

## plot the results
plot(results, type=c("g", "o"))

```

<br>
<br>

The recursive elimination selects a model containing 16 variables from the dataset. We can try a random forest using these 16 variables to see how it performs in comparison to our other models.

```{r}

## Select variables identified by the recursive feature elimination
ZQM_recursive = ZQM %>% select(c(dist_to_infest_km, max_Ca,surface_area_km, 
                                 hardness_range, perc_shrubscrub_25mi, max_pH,
                                 summer_mean_temp, perc_open_water_25mi,
                                 winter_total_precip, num_connections, mean_elev_m,
                                 summer_total_precip, perc_barren_25mi, connectivity,
                                 perc_crops_25mi, perc_open_water_50mi,infest_status))

## Set categorical data as factors
ZQM_recursive$hardness_range = as.factor(ZQM_recursive$hardness_range)
ZQM_recursive$connectivity = as.factor(ZQM_recursive$connectivity)

## Define split parameters
ZQM_recursive_split <- ZQM_recursive %>% 
  initial_split(prop = 0.8, strata = infest_status)

## Write split data to data frames
train_split_rec <- training(ZQM_recursive_split)
test_split_rec <- testing(ZQM_recursive_split)

## Train the model
rf_recursive = randomForest(as.factor(infest_status) ~ ., #writing the formula
                          data = train_split_rec, #specifying training data to be used
                          mtry = sqrt(length(train_split_rec)-1), #setting number of variables to randomly sample per each split
                          ntree= 500, #setting number of trees
                          na.action = na.omit, #specifying what to do with NAs
                          importance = TRUE #specifying importance of variables should be assessed
                          )

## Check variable importance
varImpPlot(rf_recursive,sort = T,main = "Variable importance plot")

```
<br>
Similarly to past iterations, distance to nearest infestation and maximum calcium levels are still considered the most important variables in the model.

```{r attr.output='style="max-height: 500px;"'}
#training confusion matrix
p_train <- predict(rf_recursive, newdata = train_split_rec)
confusionMatrix(p_train, as.factor(train_split_rec$infest_status),positive = '1')
```
<br>
Again, we see perfect performance with the training data.

```{r attr.output='style="max-height: 500px;"'}
#test confusion matrix
p_test <- predict(rf_recursive, newdata = test_split_rec)
confusionMatrix(p_test, as.factor(test_split_rec$infest_status),positive = '1')

#No RMSE for categorical outcomes in RF

```
Here we see an accuracy around 85%, which is close to the cutoff for statistical significance for being significantly different from the no information rate. This model has the highest sensitivity so far, indicating it is getting better at predicting Dreissenid presence.

<br>
<br>

# Conclusions (This should be expanded)

Based on our analysis, the most limiting factor related to Dreissenid presence in USACE reservoirs seems to be the distance to the closest current Dreissenid infestation. This is particularly concerning because it suggests that Dreissenid spread may be more limited by dispersal than by environmental conditions, meaning that efforts to control the spread of Dreissenids are tantamount for controlling continued expansion of populations in the U.S. Beyond distance, maximum calcium was consistently also an important variable, which aligns with past research on environmental requirements of Dreissenids...

<br> <br> <br>

# References


Benson, A. J., Raikow, D., Larson, J., Fusaro, A., Bogdanoff, A. K., and A. Elgin. (2024). *Dreissena polymorpha* (Pallas, 1771): U.S. Geological Survey, Nonindigenous Aquatic Species Database, Gainesville, Florida. https://nas.er.usgs.gov/queries/FactSheet.aspx?speciesID=5, Revision Date: 12/21/2023, Access Date: 7/29/2024

Brownlee, J. (2019). How to calculate McNemar's test to compare two machine learning classifiers. https://machinelearningmastery.com/mcnemars-test-for-machine-learning/. Access Date: 12/3/2024 

Brownlee, J. (2019). Feature selection with the Caret R Package. https://machinelearningmastery.com/feature-selection-with-the-caret-r-package/. Access Date: 12/03/2024.

Carrillo, C. C., Charbonneau, B. R., Altman, S., Keele, J. A., Pucherelli, S. F., Passamaneck, Y. J., Murphy, A. C., and T. M. Swannack. (2023). Patterns of dreissenid mussel invasions in western US lakes within an integrated gravity model framework.

Kislik, C., Dronova, I., Grantham, T. E., Kelly, M. (2022) Mapping algal bloom dynamics in small reservoirs using Sentinel-2 imagery in Google Earth Engine. Ecological Indicators, Volume 140. https://doi.org/10.1016/j.ecolind.2022.109041.

Cohen, A. N. (2005). A review of Zebra Mussels' environmental requirements: a report for the California Department of Water Resources. San Francisco Estuary Institute, Oakland, California. 33 pp.

Cohen, A. N., and A. Weinstein. (1998). The potential distribution and abundance of Zebra Mussels in California. San Francisco Estuary Institute, Richmond, California. 

Doll, B. (1997). Zebra Mussel colonization: North Carolina's risks. Sea Grant North Carolina, Raleigh, North Carolina (UNC SG-97-01).

Liaw A, and M. Wiener. (2002). Classification and regression by Random Forest. R News. 2(3):1822. Available
from: https://CRAN.R-project.org/doc/Rnews/.

Mishra, Sachidananda & Mishra, Deepak. (2012). Normalized difference chlorophyll index: A novel model for remote estimation of chlorophyll-a concentration in turbid productive waters. Remote Sensing of Environment. 117. 394-406. 10.1016/j.rse.2011.10.016. 

Sorba, E. A., and D. A. Williamson. (1997). Zebra Mussel colonization potential in Manitoba, Canada. Water Quality Management Section, Manitoba Environment, Report No. 97-07.

White, J. D., S. K. Hamilton, and O. Sarnelle. (2015). Heat-induced mass mortality of invasive Zebra Mussels (Dreissena polymorpha) at sublethal temperatures. Canadian Journal of Fisheries and Aquatic Sciences. 72(8):1221-1229. https://doi.org/10.1139/cjfas-2015-0064.

